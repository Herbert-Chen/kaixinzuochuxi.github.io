<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VTM中打印码率控制中间变量</title>
      <link href="/2019/02/26/VTM%E4%B8%AD%E6%89%93%E5%8D%B0%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F/"/>
      <url>/2019/02/26/VTM%E4%B8%AD%E6%89%93%E5%8D%B0%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要描述了在VTM中打印码率控制中间变量的方法，这些中间变量可以用来辅助分析RD模型</p><h1 id="中间变量的种类及加入位置"><a href="#中间变量的种类及加入位置" class="headerlink" title="中间变量的种类及加入位置"></a>中间变量的种类及加入位置</h1><p>将按照下面四个部分来具体展开本节</p><ul><li>文件</li><li>位置</li><li><p>具体语句</p><h2 id="宏开关-PrintTemporalResult"><a href="#宏开关-PrintTemporalResult" class="headerlink" title="宏开关 PrintTemporalResult"></a>宏开关 PrintTemporalResult</h2></li><li><p>作用<br>  控制所有的中间变量是否输出，是为输出，否为不输出</p></li><li>文件<br>  TypeDef.h </li><li>位置<br>  任意</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PrintTemporalResult                               1</span><br></pre></td></tr></table></figure><h2 id="每个编码单位的目标比特"><a href="#每个编码单位的目标比特" class="headerlink" title="每个编码单位的目标比特"></a>每个编码单位的目标比特</h2><ul><li>文件<br>  EncGOP.cpp </li><li>位置<br>  compressGOP，分配完目标码率<code>estimatedBits = m_pcRateCtrl-&gt;getRCPic()-&gt;getTargetBits();</code>之后</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">      printf(&quot;RC BEFORE: %d\t&quot;, estimatedBits);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="编码单位为intra的部分参数"><a href="#编码单位为intra的部分参数" class="headerlink" title="编码单位为intra的部分参数"></a>编码单位为intra的部分参数</h2><p>这些参数包括：</p><ul><li>MADPerPixel，16*16的块减去均值之后的MAD,除以像素的个数</li><li>bitsPerPixel，平均每个像素的比特</li><li>更正过的bpp(依据mad和bitsPerPixel计算得出，在R-$\lambda$中为<code>MADPerPixel / bitsPerPixel</code>)</li></ul><p>具体来说</p><ul><li>文件<br>  RateCtrl.cpp </li><li>位置<br>  calculateLambdaIntra,<code>return</code>之前</li><li>具体语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult </span><br><span class="line">  printf(&quot;%f\t%f\t%f\t&quot;, MADPerPixel, bitsPerPixel,bpp);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h2 id="每个编码单位的-lambda"><a href="#每个编码单位的-lambda" class="headerlink" title="每个编码单位的$\lambda$"></a>每个编码单位的$\lambda$</h2><ul><li>文件<br>  EncGOP.cpp </li><li>位置<br>  compressGOP，求解完$\lambda$和QP<br>  <code>lambda  = m_pcRateCtrl-&gt;getRCPic()-&gt;estimatePicLambda( listPreviousPicture, pcSlice-&gt;isIRAP());</code><br>  之后</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">        printf(&quot;%f\t&quot;, lambda);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="编码完成后目标比特，实际比特，目标-lambda-与实际-lambda"><a href="#编码完成后目标比特，实际比特，目标-lambda-与实际-lambda" class="headerlink" title="编码完成后目标比特，实际比特，目标$\lambda$与实际$\lambda$"></a>编码完成后目标比特，实际比特，目标$\lambda$与实际$\lambda$</h2><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  updateAlphaBetaIntra,参数更新之前</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  double bpp_real = (double)m_picActualBits / (double)m_numberOfPixel;</span><br><span class="line">  double bpp_comp = (double)m_targetBits / (double)m_numberOfPixel;</span><br><span class="line">#if PrintTemporalResult  </span><br><span class="line">  printf(&quot;\t%f\t%f\t&quot;, bpp_comp, bpp_real);</span><br><span class="line">  printf(&quot;\t%f\t%f\t&quot;, (-2 * (*a)* log(bpp_comp/3) - (*b)) / (bpp_comp), (-2 * (*a)* log(bpp_real/3)- (*b)) / (bpp_real));</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="输出更新后的模型参数"><a href="#输出更新后的模型参数" class="headerlink" title="输出更新后的模型参数"></a>输出更新后的模型参数</h2><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  updateAfterPicture，参数更新完之后（判断是否irap的条件之后）</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">  printf(&quot;\t %f\t %f\t %f\n&quot;, a, b, c);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> VVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTM </tag>
            
            <tag> video coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频编码python包框架</title>
      <link href="/2019/02/25/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81python%E5%8C%85%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/02/25/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81python%E5%8C%85%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要描述视频编码python包框架，主要功能及API</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video coding </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown插入参考文献</title>
      <link href="/2019/02/22/markdown%E6%8F%92%E5%85%A5%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"/>
      <url>/2019/02/22/markdown%E6%8F%92%E5%85%A5%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<p>几个参考文章：<br><a href="https://chalkit.tk/20171202-convert-markdown-inline-link-to-reference-footnote/" target="_blank" rel="noopener">https://chalkit.tk/20171202-convert-markdown-inline-link-to-reference-footnote/</a><br><a href="https://liuyun16.github.io/tools/2018-2-24-atom-markdown-zotero/" target="_blank" rel="noopener">https://liuyun16.github.io/tools/2018-2-24-atom-markdown-zotero/</a></p><p>1[^footnote]</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文主要针对如何在博客的markdown写作中插入参考文献进行了分析和讨论</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>预期目标是：</p><ul><li>在markdown写作中运用一种插入文献的方法，使得生成的博客能够显示出参考文献<ul><li>写作基于markdown，部署使用hexo，最终生成的是html</li></ul></li><li>参考文献应像latex的参考文献一样，具有动态更新的特性，即<ul><li>参考文献在文章中的插入地方 应与 最后的参考文献列表 具有关键词的对应关系</li></ul></li></ul><h1 id="现有的几种方法"><a href="#现有的几种方法" class="headerlink" title="现有的几种方法"></a>现有的几种方法</h1><ol><li><p>链接插入,参见第一篇文章，只能插入链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label like this, on a line by itself:</span><br><span class="line"></span><br><span class="line">[id]: http://example.com/  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure></li><li><p>脚注插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[^footnote]: Here is the *text* of the **footnote**.</span><br></pre></td></tr></table></figure></li></ol><p>存在问题：网站上显示时，会显示源代码而不是对应的格式,可以参考第一篇文章的方法解决。</p><ol start="3"><li>pandoc+bib<br>具体用法参考第二篇文章，但是并不适用与当前环境，因为使用pandoc是直接将<code>md</code>转换为<code>docx</code>，而在博客条件下我们是需要提供<code>md</code>让hexo帮我们生成<code>html</code>，所以这里暂时不讨论</li></ol><h1 id="最终选择的方法"><a href="#最终选择的方法" class="headerlink" title="最终选择的方法"></a>最终选择的方法</h1><p>最终选择用脚注的方式插入</p><h1 id="改进设想"><a href="#改进设想" class="headerlink" title="改进设想"></a>改进设想</h1><p>建立bib文件存储参考文献的信息，在原文中直接<code>\cite{xxx}</code>，然后编写一个Python文件将其替换为相应的标号和格式。</p><p>[^footnote]: a foot note</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用matlab程序</title>
      <link href="/2019/02/21/python%E8%B0%83%E7%94%A8matlab%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/02/21/python%E8%B0%83%E7%94%A8matlab%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何通过python调用matlab的<code>.m</code>文件，以及在调用中遇到的一些问题。<br>参考网址：<br><a href="https://blog.csdn.net/sunny_xsc1994/article/details/79254196" target="_blank" rel="noopener">两步解决python调用Matlab的脚本和函数文件</a><br><a href="https://blog.csdn.net/zyw_anquan/article/details/7756499" target="_blank" rel="noopener">如何在CMD下运用管理员权限</a><br><a href="https://blog.csdn.net/windymsth/article/details/78911310" target="_blank" rel="noopener">在CMD命令行中切换到管理员权限模式</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装python的matlab-engine包"><a href="#安装python的matlab-engine包" class="headerlink" title="安装python的matlab engine包"></a>安装python的matlab engine包</h2><p>此处和<a href="https://ww2.mathworks.cn/help/matlab/matlab_external/install-the-matlab-engine-for-python.html?ue" target="_blank" rel="noopener">官网</a>完全一致</p><h3 id="获取matlab文件夹路径"><a href="#获取matlab文件夹路径" class="headerlink" title="获取matlab文件夹路径"></a>获取matlab文件夹路径</h3><p>打开matlab，在命令行输入matlabroot，然后用返回值替代下面命令中的matlabroot</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>对于windows用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;matlabroot\extern\engines\python&quot;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>mac或者linux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;matlabroot/extern/engines/python&quot;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><h2 id="调用-m文件"><a href="#调用-m文件" class="headerlink" title="调用.m文件"></a>调用<code>.m</code>文件</h2><p>假设当前目录下存在<code>xxx.m</code>文件</p><h3 id="打开matlab"><a href="#打开matlab" class="headerlink" title="打开matlab"></a>打开matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matlab.engine</span><br><span class="line">eng = matlab.engine.start_matlab()</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eng.xxx(nargout=0)</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eng.xxx(para1,para2...)</span><br></pre></td></tr></table></figure></p><p>第一个是当做脚本执行，第二个是当做函数执行，括号里面为参数。按照需要执行文件的类型进行选择。</p><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>如果python文件与matlab文件在同一个目录下，不需要考虑目录问题。</p><p>如果python文件与matlab文件不在一个目录下，则需要用os模块修改目录。</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>导入包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import matlab.engine</span><br></pre></td></tr></table></figure></p><p>修改当前目录到<code>.m</code>文件目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(&apos;xxxxxxx&apos;)</span><br></pre></td></tr></table></figure></p><p>启动matlab.engine,执行文件，和先前相同。</p><p>总结起来，必须要在<code>.m</code>文件目录启动matlab.engine。如果一开始在正确目录启动，后续使用<code>os.chdir</code>修改到其他目录仍然可以执行。如果一开始不在正确目录启动，即使后面使用<code>os.chdir</code>修改到正确目录也不行。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="安装matlab-engine时python没有管理员权限"><a href="#安装matlab-engine时python没有管理员权限" class="headerlink" title="安装matlab.engine时python没有管理员权限"></a>安装matlab.engine时python没有管理员权限</h2><p>这个问题是由于管理员限制matlab文件夹的权限造成的。问题会不会出现取决于当前是否为管理员用户。如果是，则不存在这个问题，如果不是，需要给定管理员权限。</p><p>最简单的方法，开始菜单中搜索cmd，右键选择管理员运行，然后cd到目标目录下，再用python安装即可。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编程语言 </category>
          
          <category> python </category>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next的主题配置尝试</title>
      <link href="/2019/02/19/Next%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%B0%9D%E8%AF%95/"/>
      <url>/2019/02/19/Next%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文就主题选择，应用，部分参数配置与碰到的一些问题进行了简单的总结。后续遇到新的问题会继续补充。<br>主要参考博客为<a href="http://saili.science/2017/04/02/github-for-win/" target="_blank" rel="noopener">http://saili.science/2017/04/02/github-for-win/</a></p><h1 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h1><p>在<a href="https://kaixinzuochuxi.github.io/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">GITHUB+HEXO搭建博客</a>的第一个<a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">链接</a>中给出了一些主题网站，里面可选的有很多，经过一些考虑，最终还是选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>。</p><p>具体原因如下：</p><ol><li>产品免费且受众广</li><li>功能上支持中文，支持文章目录生成。</li></ol><h1 id="主题的应用"><a href="#主题的应用" class="headerlink" title="主题的应用"></a>主题的应用</h1><p>按照<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">主题网站</a>提示即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>注意以后版本更新可能会导致命令(–branch v5.1.2)有一些差异，具体以<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">主题网站</a>为主。</p><p>此种方式也可用于配置其他主题，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx themes/xxx</span><br></pre></td></tr></table></figure></p><p>在themes目录下新建主题目录<code>xxx</code>，将主题文件复制到新建目录<code>xxx</code>下，然后修改主目录下_config.yml文件中的<code>theme: xxx</code>，重新<code>hexo g</code>和<code>hexo d</code>即可。</p><h1 id="部分参数配置"><a href="#部分参数配置" class="headerlink" title="部分参数配置"></a>部分参数配置</h1><h2 id="文章的目录全显示"><a href="#文章的目录全显示" class="headerlink" title="文章的目录全显示"></a>文章的目录全显示</h2><p>next主题默认文章标题是逐渐显示的，此处如果需要将文章目录全部展开，可以在<code>next\source\css\_custom\custom.styl</code>中添加一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="运动部分"><a href="#运动部分" class="headerlink" title="运动部分"></a>运动部分</h2><h1 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h1><h2 id="语言错误"><a href="#语言错误" class="headerlink" title="语言错误"></a>语言错误</h2><p>如果一开始把站点配置文件的语言设置为简体中文(zh-Hans), 可以查找<code>theme/next/languages</code>下的文件有没有<code>zh-Hans.yml</code>。如果没有，需要将<code>zh-CN.yml</code>改名为<code>zh-Hans.yml</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VTM中添加SSIM输出</title>
      <link href="/2019/02/18/VTM%E4%B8%AD%E6%B7%BB%E5%8A%A0SSIM%E8%BE%93%E5%87%BA/"/>
      <url>/2019/02/18/VTM%E4%B8%AD%E6%B7%BB%E5%8A%A0SSIM%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="Typedef-h-中加入宏"><a href="#Typedef-h-中加入宏" class="headerlink" title="Typedef.h 中加入宏"></a>Typedef.h 中加入宏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PrintSSIM 1</span><br></pre></td></tr></table></figure><h3 id="Analyze-h-中成员和函数"><a href="#Analyze-h-中成员和函数" class="headerlink" title="Analyze.h 中成员和函数"></a>Analyze.h 中成员和函数</h3><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><h5 id="ssim数组"><a href="#ssim数组" class="headerlink" title="ssim数组"></a>ssim数组</h5><p>Analyze.h 中，在class Analyze的private成员中加入double的ssim数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double    m_MSSSIM[MAX_NUM_COMPONENT];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><h5 id="Analyze-addResult"><a href="#Analyze-addResult" class="headerlink" title="Analyze::addResult"></a>Analyze::addResult</h5><p>Analyze.h 中，在class Analyze的private成员中加入新的addResult函数,传递SSIM参数。此处用于累加每帧SSIM用来输出最后sequence level的SSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM </span><br><span class="line">  void  addResult(double psnr[MAX_NUM_COMPONENT], double bits, const double MSEyuvframe[MAX_NUM_COMPONENT], const double MSSSIM[MAX_NUM_COMPONENT], bool isEncodeLtRef)</span><br><span class="line">#else</span><br><span class="line">  void  addResult( double psnr[MAX_NUM_COMPONENT], double bits, const double MSEyuvframe[MAX_NUM_COMPONENT]</span><br><span class="line">    , bool isEncodeLtRef</span><br><span class="line">  )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="新增访问ssim函数：getMsssim"><a href="#新增访问ssim函数：getMsssim" class="headerlink" title="新增访问ssim函数：getMsssim"></a>新增访问ssim函数：getMsssim</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double   getMsssim(ComponentID compID) const &#123; return  m_MSSSIM[compID]; &#125;</span><br><span class="line">#endif</span><br><span class="line">  double  getPsnr(ComponentID compID) const &#123; return  m_dPSNRSum[compID];  &#125;</span><br><span class="line">  double  getBits()                   const &#123; return  m_dAddBits;   &#125;</span><br><span class="line">  void    setBits(double numBits)     &#123; m_dAddBits = numBits; &#125;</span><br><span class="line">  uint32_t    getNumPic()                 const &#123; return  m_uiNumPic;   &#125;</span><br></pre></td></tr></table></figure><h4 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h4><h5 id="Analyze-addResult-1"><a href="#Analyze-addResult-1" class="headerlink" title="Analyze::addResult"></a>Analyze::addResult</h5><p>Analyze.h 中，addResult，SSIM数据的累加更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    for(uint32_t i=0; i&lt;MAX_NUM_COMPONENT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      m_dPSNRSum[i] += psnr[i];</span><br><span class="line">      m_MSEyuvframe[i] += MSEyuvframe[i];</span><br><span class="line">#if PrintSSIM</span><br><span class="line">      m_MSSSIM[i] += MSSSIM[i];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="Analyze-clear"><a href="#Analyze-clear" class="headerlink" title="Analyze::clear"></a>Analyze::clear</h5><p>Analyze.h 中，clear，SSIM数据归零：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      m_dPSNRSum[i] = 0;</span><br><span class="line">      m_MSEyuvframe[i] = 0;</span><br><span class="line">#if PrintSSIM</span><br><span class="line">      m_MSSSIM[i] = 0;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="Analyze-printout"><a href="#Analyze-printout" class="headerlink" title="Analyze::printout"></a>Analyze::printout</h5><p>Analyze.h 中，printout函数，负责输出最后的summary<br>一共8个地方需要添加：</p><ul><li>Y-MS-SSIM标志位</li><li>具体SSIM的数值，</li><li>依据是否为printMSEBasedSNR</li><li>400和其他的yuv格式</li></ul><p>8个地方的位置可以通过<code>if (printSequenceMSE)</code>来查找，直接放在<code>if (printSequenceMSE)</code>之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">400：</span><br><span class="line">#if PrintSSIM          </span><br><span class="line">          msg(e_msg_level, &quot;    Y-MS-SSIM&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">          msg(e_msg_level, &quot;    %8.6lf&quot;, getMsssim(COMPONENT_Y) / (double)getNumPic());</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">其他</span><br><span class="line">#if PrintSSIM</span><br><span class="line">              //printf(&quot;   Y-MS-SSIM    &quot; &quot;U-MS-SSIM    &quot; &quot;V-MS-SSIM &quot;);</span><br><span class="line">            msg(e_msg_level, &quot;    Y-MS-SSIM     &quot;  &quot;U-MS-SSIM     &quot;  &quot;V-MS-SSIM     &quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">            /*</span><br><span class="line">            printf(&quot;    %8.6lf     &quot; &quot;%8.6lf     &quot; &quot;%8.6lf &quot;,</span><br><span class="line">              getMsssim(COMPONENT_Y) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cb) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cr) / (double)getNumPic());</span><br><span class="line">              */</span><br><span class="line">            msg(e_msg_level, &quot;    %8.6lf     &quot; &quot;%8.6lf     &quot; &quot;%8.6lf &quot;,</span><br><span class="line">              getMsssim(COMPONENT_Y) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cb) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cr) / (double)getNumPic());</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="EncGOP中的成员和函数"><a href="#EncGOP中的成员和函数" class="headerlink" title="EncGOP中的成员和函数"></a>EncGOP中的成员和函数</h3><h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><p>没有需要添加的成员</p><h4 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h4><h5 id="新增EncGOP-xCalculateAddPSNR"><a href="#新增EncGOP-xCalculateAddPSNR" class="headerlink" title="新增EncGOP::xCalculateAddPSNR"></a>新增EncGOP::xCalculateAddPSNR</h5><p>EncGOP.h中新增xCalculateMSSSIM，用来计算图片的SSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double xCalculateMSSSIM(const CPelBuf pcPic, const uint32_t orgStride, const CPelBuf cPicD, const uint32_t recStride, const uint32_t width, const uint32_t height, const uint32_t bitDepth);</span><br><span class="line">#endif</span><br><span class="line">  uint64_t xFindDistortionPlane(const CPelBuf&amp; pic0, const CPelBuf&amp; pic1, const uint32_t rshift</span><br></pre></td></tr></table></figure></p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><h5 id="EncGOP-xCalculateAddPSNR"><a href="#EncGOP-xCalculateAddPSNR" class="headerlink" title="EncGOP::xCalculateAddPSNR"></a>EncGOP::xCalculateAddPSNR</h5><p>一共有2个地方</p><ul><li>调用函数计算ssim</li><li>重载analyze模块的addResult函数</li></ul><p>calculate PSNR之后和<code>#if EXTENSION_360_VIDEO</code>之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double  MSSSIM[MAX_NUM_COMPONENT] = &#123; 0,0,0 &#125;;</span><br><span class="line">  for (int chan = 0; chan&lt;::getNumberValidComponents(formatD); chan++)</span><br><span class="line">  &#123;</span><br><span class="line">    const ComponentID compID = ComponentID(chan);</span><br><span class="line"></span><br><span class="line">    const CPelBuf&amp;    p = picC.get(compID);</span><br><span class="line">    const CPelBuf&amp;    o = org.get(compID);</span><br><span class="line">    const int   orgStride = o.stride;</span><br><span class="line"></span><br><span class="line">    const int   recStride = p.stride;</span><br><span class="line">    const uint32_t   width = p.width - (m_pcEncLib-&gt;getPad(0) &gt;&gt; ::getComponentScaleX(compID, format));</span><br><span class="line">    const uint32_t   height = p.height - (m_pcEncLib-&gt;getPad(1) &gt;&gt; (!!bPicIsField + ::getComponentScaleY(compID, format)));</span><br><span class="line">    const uint32_t    bitDepth = sps.getBitDepth(toChannelType(compID));</span><br><span class="line"></span><br><span class="line">    MSSSIM[compID] = xCalculateMSSSIM(o, orgStride, p, recStride, width, height, bitDepth);</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>调用addPSNR时,选择新函数传递ssim成员,<br>all,I,P,B一共4个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  m_gcAnalyzeAll.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">  m_gcAnalyzeAll.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">    , isEncodeLtRef</span><br><span class="line">  );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeI.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeI.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeP.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeP.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNRWeighted, (double)uibits, MSEyuvframeWeighted, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeWPSNR.addResult(dPSNRWeighted, (double)uibits, MSEyuvframeWeighted, isEncodeLtRef);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>输出每帧信息，if( printFrameMSE )之前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">    printf(&quot; [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]&quot;, MSSSIM[COMPONENT_Y], MSSSIM[COMPONENT_Cb], MSSSIM[COMPONENT_Cr]);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if( printFrameMSE )</span><br><span class="line">    &#123;</span><br><span class="line">      msg( NOTICE, &quot; [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]&quot;, MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="EncGOP-xCalculateMSSSIM"><a href="#EncGOP-xCalculateMSSSIM" class="headerlink" title="EncGOP::xCalculateMSSSIM"></a>EncGOP::xCalculateMSSSIM</h5><p>在EncGOP::xCalculateAddPSNR之后，定义xCalculateMSSSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">double EncGOP::xCalculateMSSSIM(const CPelBuf pOrg, const uint32_t orgStride, const CPelBuf pRec, const uint32_t recStride, const uint32_t width, const uint32_t height, const uint32_t bitDepth)</span><br><span class="line">&#123;</span><br><span class="line">  const int MAX_MSSSIM_SCALE = 5;</span><br><span class="line">  const int WEIGHTING_MID_TAP = 5;</span><br><span class="line">  const int WEIGHTING_SIZE = WEIGHTING_MID_TAP * 2 + 1;</span><br><span class="line"></span><br><span class="line">  uint32_t maxScale;</span><br><span class="line"></span><br><span class="line">  // For low resolution videos determine number of scales </span><br><span class="line">  if (width &lt; 22 || height &lt; 22)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 44 || height &lt; 44)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 88 || height &lt; 88)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 176 || height &lt; 176)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(maxScale&gt;0 &amp;&amp; maxScale &lt;= MAX_MSSSIM_SCALE);</span><br><span class="line"></span><br><span class="line">  //Normalized Gaussian mask design, 11*11, s.d. 1.5</span><br><span class="line">  double weights[WEIGHTING_SIZE][WEIGHTING_SIZE];</span><br><span class="line">  &#123;</span><br><span class="line">    double coeffSum = 0.0;</span><br><span class="line">    for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        weights[y][x] = exp(-((y - WEIGHTING_MID_TAP)*(y - WEIGHTING_MID_TAP) + (x - WEIGHTING_MID_TAP)*(x - WEIGHTING_MID_TAP)) / (WEIGHTING_MID_TAP - 0.5));</span><br><span class="line">        coeffSum += weights[y][x];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        weights[y][x] /= coeffSum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //Resolution based weights</span><br><span class="line">  const double exponentWeights[MAX_MSSSIM_SCALE][MAX_MSSSIM_SCALE] = &#123; &#123; 1.0,    0,      0,      0,      0 &#125;,</span><br><span class="line">  &#123; 0.1356, 0.8644, 0,      0,      0 &#125;,</span><br><span class="line">  &#123; 0.0711, 0.4530, 0.4760, 0,      0 &#125;,</span><br><span class="line">  &#123; 0.0517, 0.3295, 0.3462, 0.2726, 0 &#125;,</span><br><span class="line">  &#123; 0.0448, 0.2856, 0.3001, 0.2363, 0.1333 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">  //Downsampling of data:</span><br><span class="line">  std::vector&lt;double&gt; original[MAX_MSSSIM_SCALE];</span><br><span class="line">  std::vector&lt;double&gt; recon[MAX_MSSSIM_SCALE];</span><br><span class="line"></span><br><span class="line">  for (uint32_t scale = 0; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    original[scale].resize(scaledHeight*scaledWidth, double(0));</span><br><span class="line">    recon[scale].resize(scaledHeight*scaledWidth, double(0));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Initial [0] arrays to be a copy of the source data (but stored in array &quot;Double&quot;, not Pel array).</span><br><span class="line">  for (int y = 0; y&lt;height; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int x = 0; x&lt;width; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      original[0][y*width + x] = pOrg.buf[y*orgStride + x];</span><br><span class="line">      recon[0][y*width + x] = pRec.buf[y*recStride + x];</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set up other arrays to be average value of each 2x2 sample.</span><br><span class="line">  for (uint32_t scale = 1; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    for (int y = 0; y&lt;scaledHeight; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;scaledWidth; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        original[scale][y*scaledWidth + x] = (original[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          original[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x + 1] +</span><br><span class="line">          original[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          original[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x + 1]) / 4.0;</span><br><span class="line">        recon[scale][y*scaledWidth + x] = (recon[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          recon[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x + 1] +</span><br><span class="line">          recon[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          recon[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x + 1]) / 4.0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Calculate MS-SSIM:</span><br><span class="line">  const uint32_t   maxValue = (1 &lt;&lt; bitDepth) - 1;</span><br><span class="line">  const double c1 = (0.01*maxValue)*(0.01*maxValue);</span><br><span class="line">  const double c2 = (0.03*maxValue)*(0.03*maxValue);</span><br><span class="line"></span><br><span class="line">  double finalMSSSIM = 1.0;</span><br><span class="line"></span><br><span class="line">  for (uint32_t scale = 0; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    const int blocksPerRow = scaledWidth - WEIGHTING_SIZE + 1;</span><br><span class="line">    const int blocksPerColumn = scaledHeight - WEIGHTING_SIZE + 1;</span><br><span class="line">    const int totalBlocks = blocksPerRow * blocksPerColumn;</span><br><span class="line"></span><br><span class="line">    double meanSSIM = 0.0;</span><br><span class="line"></span><br><span class="line">    for (int blockIndexY = 0; blockIndexY&lt;blocksPerColumn; blockIndexY++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int blockIndexX = 0; blockIndexX&lt;blocksPerRow; blockIndexX++)</span><br><span class="line">      &#123;</span><br><span class="line">        double muOrg = 0.0;</span><br><span class="line">        double muRec = 0.0;</span><br><span class="line">        double muOrigSqr = 0.0;</span><br><span class="line">        double muRecSqr = 0.0;</span><br><span class="line">        double muOrigMultRec = 0.0;</span><br><span class="line"></span><br><span class="line">        for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">        &#123;</span><br><span class="line">          for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">          &#123;</span><br><span class="line">            const double gaussianWeight = weights[y][x];</span><br><span class="line">            const int    sampleOffset = (blockIndexY + y)*scaledWidth + (blockIndexX + x);</span><br><span class="line">            const double orgPel = original[scale][sampleOffset];</span><br><span class="line">            const double recPel = recon[scale][sampleOffset];</span><br><span class="line"></span><br><span class="line">            muOrg += orgPel * gaussianWeight;</span><br><span class="line">            muRec += recPel * gaussianWeight;</span><br><span class="line">            muOrigSqr += orgPel * orgPel*gaussianWeight;</span><br><span class="line">            muRecSqr += recPel * recPel*gaussianWeight;</span><br><span class="line">            muOrigMultRec += orgPel * recPel*gaussianWeight;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const double sigmaSqrOrig = muOrigSqr - (muOrg*muOrg);</span><br><span class="line">        const double sigmaSqrRec = muRecSqr - (muRec*muRec);</span><br><span class="line">        const double sigmaOrigRec = muOrigMultRec - (muOrg*muRec);</span><br><span class="line"></span><br><span class="line">        double blockSSIMVal = ((2.0*sigmaOrigRec + c2) / (sigmaSqrOrig + sigmaSqrRec + c2));</span><br><span class="line">        if (scale == maxScale - 1)</span><br><span class="line">        &#123;</span><br><span class="line">          blockSSIMVal *= (2.0*muOrg*muRec + c1) / (muOrg*muOrg + muRec * muRec + c1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        meanSSIM += blockSSIMVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meanSSIM /= totalBlocks;</span><br><span class="line"></span><br><span class="line">    finalMSSSIM *= pow(meanSSIM, exponentWeights[maxScale - 1][scale]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return finalMSSSIM;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="EncGOP-xCalculateInterlacedAddPSNR"><a href="#EncGOP-xCalculateInterlacedAddPSNR" class="headerlink" title="EncGOP::xCalculateInterlacedAddPSNR"></a>EncGOP::xCalculateInterlacedAddPSNR</h5><p>xCalculateInterlacedAddPSNR中暂时不修改，因为现在不需要field coding。但需要增加两项内容避免报错：</p><p>计算ssim,在计算psnr之后和<code>uint32_t uibits = 0;</code>之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  //===== calculate MS-SSIM =====</span><br><span class="line">  double MSSSIM[MAX_NUM_COMPONENT] = &#123; 0,0,0 &#125;;</span><br><span class="line">  /*</span><br><span class="line">  </span><br><span class="line">    for (int chan = 0; chan&lt;numValidComponents; chan++)</span><br><span class="line">    &#123;</span><br><span class="line">      const ComponentID ch = ComponentID(chan);</span><br><span class="line">      assert(acPicRecFields[0]-&gt;getWidth(ch) == acPicRecFields[1]-&gt;getWidth(ch));</span><br><span class="line">      assert(acPicRecFields[0]-&gt;getHeight(ch) == acPicRecFields[1]-&gt;getHeight(ch));</span><br><span class="line"></span><br><span class="line">      double sumOverFieldsMSSSIM = 0.0;</span><br><span class="line">      const uint32_t width = acPicRecFields[0].get(ch).width - (m_pcEncLib-&gt;getPad(0) &gt;&gt; ::getComponentScaleX(ch, format));</span><br><span class="line">      const uint32_t height = acPicRecFields[0].get(ch).height - ((m_pcEncLib-&gt;getPad(1) &gt;&gt; 1) &gt;&gt; ::getComponentScaleY(ch, format));</span><br><span class="line"></span><br><span class="line">      for (uint32_t fieldNum = 0; fieldNum&lt;2; fieldNum++)</span><br><span class="line">      &#123;</span><br><span class="line">        Picture    pcPic = *apcPicOrgFields[fieldNum];</span><br><span class="line">        PelUnitBuf pcPicD = acPicRecFields[fieldNum];</span><br><span class="line">        const CPelBuf&amp;    p = pcPic.get(ch);</span><br><span class="line">        const CPelBuf&amp;    o = pcPicD.get(ch);</span><br><span class="line">        const Pel*  pOrg = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic.getPicYuvTrueOrg()-&gt;getAddr(ch) : pcPic-&gt;getPicYuvOrg()-&gt;getAddr(ch);</span><br><span class="line">        const uint32_t   orgStride = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic-&gt;getPicYuvTrueOrg()-&gt;getStride(ch) : pcPic-&gt;getPicYuvOrg()-&gt;getStride(ch);</span><br><span class="line">        Pel*        pRec = pcPicD-&gt;getAddr(ch);</span><br><span class="line">        const uint32_t   recStride = pcPicD-&gt;getStride(ch);</span><br><span class="line">        const uint32_t  bitDepth = sps.getBitDepth(toChannelType(ch));</span><br><span class="line"></span><br><span class="line">        sumOverFieldsMSSSIM += xCalculateMSSSIM(pOrg, orgStride, pRec, recStride, width, height, bitDepth);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MSSSIM[ch] = sumOverFieldsMSSSIM / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>addResult，和先前非field coding编码一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  m_gcAnalyzeAll_in.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">  m_gcAnalyzeAll_in.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">    , isEncodeLtRef</span><br><span class="line">  );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> VVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下C++编译</title>
      <link href="/2018/04/25/linux%E4%B8%8BC-%E7%BC%96%E8%AF%91/"/>
      <url>/2018/04/25/linux%E4%B8%8BC-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="linux下C-编译"><a href="#linux下C-编译" class="headerlink" title="linux下C++编译"></a>linux下C++编译</h1><p>本文来自<a href="http://wiki.ubuntu.org.cn/Compiling_Cpp" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/Compiling_Cpp</a></p><p>C++编译有不同指令，所有指令都需要源码作为输入，根据输出结果不同可以分为以下几类：</p><ul><li>生成可执行文件<br>单个文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g++ helloworld.cpp      # 生成a.out的可执行文件</span><br><span class="line">g++ helloworld.cpp -o helloworld    # 自定义可执行文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># g++是gcc的一个特殊版本，链接是使用C++标准库不使用C标准库，可以指定编译库的名称</span><br><span class="line">gcc helloworld.cpp -lstdc++ -o helloworld</span><br><span class="line"># 某些系统GCC安装也会有c++,可以替代g++</span><br><span class="line">c++ helloworld.cpp -o helloworld</span><br><span class="line"># 执行</span><br><span class="line">./xxx.out</span><br><span class="line">./xxx</span><br></pre></td></tr></table></figure></li></ul><p>多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ xxx.cpp xxx.cpp -o xxxx</span><br></pre></td></tr></table></figure></p><p>参数不需要<code>.h</code>文件，只需要<code>.cpp</code></p><ul><li>生成对象文件<br>仅编译，不链接城可执行文件，文件名默认与源文件名相同</li><li>编译预处理</li><li>生成汇编代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GITHUB+HEXO搭建博客</title>
      <link href="/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍用github与hexo搭建个人博客。</p><p>网上此类文章比较多，在此列举几条，可以按照下面链接的内容一步一步操作。</p><ul><li>基本框架(安装程序，搭建博客，发表文章，配置信息，更改主题)<br><a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">https://github.com/limedroid/HexoLearning</a></li><li>域名等其他内容添加<br><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></li><li>常见报错<br><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%A1%B5%E9%9D%A2%E9%95%BF%E6%97%B6%E9%97%B4404" target="_blank" rel="noopener">https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%A1%B5%E9%9D%A2%E9%95%BF%E6%97%B6%E9%97%B4404</a></li><li><p>常见命令<br>  <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 新文章</span><br><span class="line">hexo new [layout] &lt;title&gt;   # layout缺省，使用 _config.yml中default_layout代替</span><br><span class="line"># generate</span><br><span class="line">hexo generate   #简写hexo g</span><br><span class="line">--deploy/-d 文件生成后立即部署网站</span><br><span class="line">--watch/-w  监视文件变动</span><br><span class="line"># 发布草稿</span><br><span class="line">hexo publish [layout] &lt;filename&gt;</span><br><span class="line"># server</span><br><span class="line">hexo server #默认端口4000</span><br><span class="line">-p/--port   指定端口</span><br><span class="line">-s/--static 只使用静态文件</span><br><span class="line">-l/--log    启动日记记录，使用覆盖记录格式</span><br><span class="line"></span><br><span class="line"># deploy</span><br><span class="line">hexo deploy # 简写为hexo d</span><br><span class="line">-g/--generate 部署之前预先生成静态文件</span><br><span class="line"></span><br><span class="line">未完待定</span><br></pre></td></tr></table></figure></li><li><p>写作格式：</p><ul><li>tags<ul><li>[tag1,tag2…]</li><li>YAML格式，类似markdown中的格式</li></ul></li></ul></li></ul><p>几个注意事项：</p><ul><li>本地部署<code>hexo s</code>的时候win10可能无法打开默认的<code>localhost:4000</code>，此时需要使用自定义端口<code>hexo s -p 3600</code></li><li>本地文件与<code>xxx.github.io</code>仓库中文件的关系：<ul><li>将本地目录中<code>public</code>文件夹下内容上传到仓库，本人在此文件夹下使用<code>git init</code>。</li><li>部署时可以直接在本地博客目录下使用<code>hexo g</code>,<code>hexo d</code>部署，如果当前已经部署导致报错，删除<code>.deploy_git</code>即可。</li><li>不要轻易使用<code>hexo clean</code>，此操作会重新生成<code>public</code>文件夹,从而导致<code>public</code>文件夹下<code>.git</code>被删除，需要重新与仓库建立关系。此处可使用<code>git push --force origin master</code>强行覆盖。</li></ul></li><li><code>xxx.github.io</code>网址上内容的更新需要一段时间，可以先本地测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/11/hello-world/"/>
      <url>/2018/04/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
