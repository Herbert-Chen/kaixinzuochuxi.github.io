<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python多线程并行计算</title>
      <link href="/2019/07/10/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/07/10/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了在Python中实现并行计算的办法。</p><a id="more"></a><h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>最简单的场景：<br>同一个函数，需要在不同的输入下分别运行，此时即可使用并行计算方法。</p><p><strong>参考文献</strong>：<br><a href="https://blog.csdn.net/SeeTheWorld518/article/details/49639651" target="_blank" rel="noopener">Python 多进程 multiprocessing.Pool类详解</a><br><a href="https://abcdabcd987.com/python-multiprocessing/" target="_blank" rel="noopener">Python 多核并行计算</a></p><h1 id="模块与类"><a href="#模块与类" class="headerlink" title="模块与类"></a>模块与类</h1><p>此部分介绍了两种多线程的方法，分别为<code>multiprocessing.Process()</code>和<code>multiprocessing.Pool()</code>。<br>他们之间的区别为：</p><ul><li>任务与进程的对应关系，<code>Process()</code>一个任务对应一个进程，但<code>Pool()</code>并没有准确的对应关系，每来一个任务，如果进程池没满，就会创建一个进程执行；如果进程池满了，则会等待池中进程结束再来执行当前任务。<ul><li>由此导致在进程数量管理上，<code>Pool()</code>比<code>Process()</code>更方便，不需要手动为任务分配进程。</li></ul></li></ul><h2 id="multiprocessing-Process"><a href="#multiprocessing-Process" class="headerlink" title="multiprocessing.Process()"></a><code>multiprocessing.Process()</code></h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__init__(self, group=None, target=None, name=None, args=(), kwargs=&#123;&#125;)</span><br></pre></td></tr></table></figure><p>目前需要注意的是，target表示调用对象，如函数名，args是函数的输入参数。</p><p>借用参考文献中的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def do(n) :</span><br><span class="line">  #获取当前线程的名字</span><br><span class="line">  name = multiprocessing.current_process().name</span><br><span class="line">  print name,&apos;starting&apos;</span><br><span class="line">  print &quot;worker &quot;, n</span><br><span class="line">  return </span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos; :</span><br><span class="line">  numList = []</span><br><span class="line">  for i in xrange(5) :</span><br><span class="line">    p = multiprocessing.Process(target=do, args=(i,))</span><br><span class="line">    numList.append(p)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print &quot;Process end.&quot;</span><br></pre></td></tr></table></figure></p><p><code>p.start()</code>,启动进程，<code>p.join()</code>,等待当前进程结束之后再继续，常用于进程间的同步。</p><h2 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool()"></a><code>multiprocessing.Pool()</code></h2><p>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool = Pool(5)</span><br><span class="line">rl =pool.map(func, Para_inter) # 可以设置左值，对于函数没有返回值的情况</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">def run(fn):</span><br><span class="line">  #fn: 函数参数是数据列表的一个元素</span><br><span class="line">  time.sleep(1)</span><br><span class="line">  return fn*fn</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">  testFL = [1,2,3,4,5,6]  </span><br><span class="line">  print &apos;shunxu:&apos; #顺序执行(也就是串行执行，单进程)</span><br><span class="line">  s = time.time()</span><br><span class="line">  for fn in testFL:</span><br><span class="line">    run(fn)</span><br><span class="line"></span><br><span class="line">  e1 = time.time()</span><br><span class="line">  print &quot;顺序执行时间：&quot;, int(e1 - s)</span><br><span class="line"></span><br><span class="line">  print &apos;concurrent:&apos; #创建多个进程，并行执行</span><br><span class="line">  pool = Pool(5)  #创建拥有5个进程数量的进程池</span><br><span class="line">  #testFL:要处理的数据列表，run：处理testFL列表中数据的函数</span><br><span class="line">  rl =pool.map(run, testFL) </span><br><span class="line">  pool.close()#关闭进程池，不再接受新的进程</span><br><span class="line">  pool.join()#主进程阻塞等待子进程的退出</span><br><span class="line">  e2 = time.time()</span><br><span class="line">  print &quot;并行执行时间：&quot;, int(e2-e1)</span><br><span class="line">  print rl</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(func, iterable[, chunksize=None])</span><br></pre></td></tr></table></figure><p>func为函数名，后面的迭代器中为函数参数。map的赋值对象表示返回值的列表，等所有进程执行完毕之后才回返回。顺序不一定与输入顺序一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close()</span><br></pre></td></tr></table></figure><p>关闭进程池，不接受新的任务，已经接受的任务会继续进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terminate()</span><br></pre></td></tr></table></figure><p>结束所有的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join()</span><br></pre></td></tr></table></figure><p>主进程阻塞等待子进程的退出，然后再执行后面的语句，join方法必须在close或terminate之后使用。</p><p>如果函数需要传递多个参数，则需要分别构建每个参数的列表，zip，并且重新定义函数为单一变量函数，将所有变量作为一个tuple传入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f_zipped(para):</span><br><span class="line">    f(para[0]...)</span><br><span class="line"></span><br><span class="line">pool.map(f_zipped,zip(paralist1,paralist2...))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VTM4.0�е�QPA</title>
      <link href="/2019/07/09/VTM4-0%E4%B8%AD%E7%9A%84QPA/"/>
      <url>/2019/07/09/VTM4-0%E4%B8%AD%E7%9A%84QPA/</url>
      
        <content type="html"><![CDATA[<p>������Ҫ�����ˣ�QPA��VTM4.0�е�QPA����᰸��ԭ����ʵ�֡�</p><a id="more"></a><h1 id="QPA"><a href="#QPA" class="headerlink" title="QPA"></a>QPA</h1><p>QPA ��quantization parameter adaption ����д��Ҳ���Ա�ʾΪAQP�� adaptive quantization parameter��</p><p>��������;�ǣ���fix QP�����У�ͨ��������Ƶ��content information����frame level����ctu level��QP�������Ӷ��ﵽ�Ż�����RD���ܵ�Ŀ�ġ�</p><p>�Ż�ctu level��QP�����¼���˼·��</p><ul><li>ROI�Ż�<ul><li>�������������Ż�</li><li>�Բ�ͬJND�����Ż�</li></ul></li><li>���������ϵ�Ż�<ul><li>����֡������ģ��(����D��ǰ��)�����Ż�</li><li>����֡��������ǿ��(CU-Tree)�����Ż�</li></ul></li></ul><h1 id="VTM4-0�е�QPA����᰸"><a href="#VTM4-0�е�QPA����᰸" class="headerlink" title="VTM4.0�е�QPA����᰸"></a>VTM4.0�е�QPA����᰸</h1><p>�����᰸��Improved perceptually optimized QP adaptation and associated distortion measure�� JVET-K0206<br>�������᰸���������֤�Ͳ��ֲ����޸ģ�������JVET-H0047-v5��JVET-M0091-v1��</p><p>��Ҫ�ο�JVET-K0206��JVET-H0047-v5���ɡ�</p><h1 id="VTM4-0�е�QPA��ԭ��"><a href="#VTM4-0�е�QPA��ԭ��" class="headerlink" title="VTM4.0�е�QPA��ԭ��"></a>VTM4.0�е�QPA��ԭ��</h1><p>���������͹�ʽ����JVET-K0206���ҵ���</p><p>key words�� perceptually suboptimal, low-medium bitrates, visual activity<br>˼·�������������������������͸���������������<br>ԭ���Ӿ��ϣ������������ʧ���������</p><p>������ڵ����⣺�����PSNR�����½�<br>ԭ��û�������Ӿ��ļ�ȨЧ��<br>���裺ͬһ֡�Ŀ����ж����ԣ����Ը������SSEʧ����Ե��ӡ�<br>ԭʼ�汾RDO��<br>$$<br>\begin{aligned}<br> J &amp;=D_{pic}+\lambda_{pic}\cdot R_{pic}\<br> &amp;=\sum_{k} D_{k}+ \lambda_{pic}\cdot(\sum_kR_{k})<br>\end{aligned}<br>$$<br>��Ȩ�汾RDO,�������Լ��裺<br>$$<br>\begin{aligned}<br> J &amp;=D_{pic}+\lambda_{pic}\cdot R_{pic}\<br> &amp;=\sum_{k} w_k\cdot D_{k}+ \lambda_{pic}\cdot(\sum_kR_{k})\<br> &amp;=\sum_{k} (w_k\cdot D_{k}+\lambda_{pic}\cdot R_{k})\<br> &amp;=\sum_{k} w_k\cdot(D_{k}+\lambda_{pic}/w_k \cdot R_{k})\<br> &amp;=\sum_{k} w_k\cdot(D_{k}+\lambda_{k} \cdot R_{k})<br>\end{aligned}<br>$$<br>����$$\lambda_{k}\propto \triangle_k^2 (\text{QP stepsize}) \propto 2^{\frac{QP_k}{6}}$$, ����$$QP_k=QP-3\log_2w_k$$</p><p>WPSNR�ļ��㣺$$WPSNR=10\log_{10}(\frac{W\cdot H \cdot 255^2 \cdot 2^{2B-16}}{D_{pic}^{WSSE}})$$, �ʹ�ͳ��PSNR���������SSE�Ǽ�Ȩ��SSE��</p><h2 id="���岽�裺"><a href="#���岽�裺" class="headerlink" title="���岽�裺"></a>���岽�裺</h2><ul><li>���㵱ǰ���Ȩ��<ul><li>��ͨ�˲���4��ͷ,���㵱ǰλ�����غ����������ĸ����صĲ��$$H(x,y)=4S(x,y)-S(x+1,y)-S(x-1,y)-S(x,y+1)-S(x,y-1)$$</li><li>��ÿ����$B_k$, ����local activity(�������ƽ���̶ȣ�����������Ӷ�)��$$a_k=\max(1,(\frac{1}{|B_k^<em>|}\sum|h(x,y)|)^2)$$��$B_k^</em>$��ʾ��ǰ��ȥ��������һȦ���صĿ�(h-2,w-2)</li><li>��֡�����п���ƽ��$a_{pic}$</li><li>���Ȩ��$$w_k=(\frac{a_{pic}}{a_k})^{\beta}$$,$\beta=0.5$</li></ul></li><li>��⵱ǰ���QPA$$QP_k=QP-3\log_2w_k$$</li></ul><h2 id="�����k���"><a href="#�����k���" class="headerlink" title="�����ķ���"></a>�����ķ���</h2><ol><li>����Խƽ����Ȩ��Խ�ߣ�$QP_k$ԽС</li><li>$a_k=\max(1,(\frac{1}{|B_k^*|}\sum|h(x,y)|)^2)$��1�����ã�ƽ�������<strong>�ض�</strong>Ȩ�ء�Խ����ƽ������Ȩ��ԽС��ԽС��ƽ������Ȩ��Խ��</li><li>$\beta=0.5$��ͬ������Ȩ�صķ��䡣�Եõ���Ȩ��ֱ�ӽ���ָ��<strong>����</strong>������Ȩ�صķֲ���Խ����ֲ�Խ��ɢ��ƽ���븴������Ĳ��Խ��ԽС��ֲ�Խ���У����ԽС��<h2 id="ԭ�������"><a href="#ԭ�������" class="headerlink" title="ԭ�������"></a>ԭ�������</h2></li><li>�����Ȩ�ص����ܲ��ܴ����Ӿ����ԣ�Ŀǰ��֪���Ӿ�������saliency��JND��һ����˵������������saliency�Ƚϸߣ�JNDҲ�Ƚϸߣ���ô���ּ���Ӧ�����������һ������JND��Ȩ�أ������Ƿ�����д���ȶ��</li><li>�������Լ��裬���������ȽϿ��̡�</li></ol><h1 id="VTM4-0�е�QPA�L���"><a href="#VTM4-0�е�QPA�L���" class="headerlink" title="VTM4.0�е�QPA�Ŀ���"></a>VTM4.0�е�QPA�Ŀ���</h1><p>�ڵ�ǰ<code>software manual</code>�У�AQP����<code>--AdaptiveQP</code>��<code>-aqp</code>�������ʵ���ϴ�����������Ч�ġ�Ŀǰ����Ĳ���Ӧ����<code>-qpa 1</code>����ʱPSNRΪδ��ȨPSNR,����õ���Ȩ��WPSNR����Ҫ<code>-wpsnr 1</code></p><h1 id="VTM4-0�е�QPA�J���"><a href="#VTM4-0�е�QPA�J���" class="headerlink" title="VTM4.0�е�QPA�Ĵ���"></a>VTM4.0�е�QPA�Ĵ���</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目申请中个人简历的几点注意事项</title>
      <link href="/2019/06/09/%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B8%AD%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E7%9A%84%E5%87%A0%E7%82%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2019/06/09/%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B8%AD%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E7%9A%84%E5%87%A0%E7%82%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了制作申请项目的简历时几个值得注意的地方。<br><a id="more"></a></p><h1 id="一些基本的格式"><a href="#一些基本的格式" class="headerlink" title="一些基本的格式"></a>一些基本的格式</h1><h2 id="学历，专业资格，工作经验"><a href="#学历，专业资格，工作经验" class="headerlink" title="学历，专业资格，工作经验"></a>学历，专业资格，工作经验</h2><h3 id="不同学历，专业资格，工作经验的顺序性"><a href="#不同学历，专业资格，工作经验的顺序性" class="headerlink" title="不同学历，专业资格，工作经验的顺序性"></a>不同学历，专业资格，工作经验的顺序性</h3><p>按照时间顺序，从小到大。</p><h3 id="一条学历，专业资格，工作经验之间的顺序性"><a href="#一条学历，专业资格，工作经验之间的顺序性" class="headerlink" title="一条学历，专业资格，工作经验之间的顺序性"></a>一条学历，专业资格，工作经验之间的顺序性</h3><p>这里主要是内容的顺序性。英文里面一般的内容和内容的顺序如下：</p><ul><li>时间。</li><li>职位/学历，如实习生等。</li><li>单位，单位的细分，如xx学校，xx院，xx专业。</li><li>地址，从小到大。</li></ul><h2 id="论文，专利"><a href="#论文，专利" class="headerlink" title="论文，专利"></a>论文，专利</h2><ol><li>来源相同，比如全部从google上引用，而不是一半google一半dblp。</li><li>自己的名字加粗。</li></ol><h1 id="几个值得注意的地方"><a href="#几个值得注意的地方" class="headerlink" title="几个值得注意的地方"></a>几个值得注意的地方</h1><h2 id="格式的一致性"><a href="#格式的一致性" class="headerlink" title="格式的一致性"></a>格式的一致性</h2><p>格式的一致性包括：</p><ul><li>字体的一致性，全篇文本的文字字体相同。</li><li>标点符号的一致性，<ul><li>分隔符的一致性：<code>,</code>, <code>;</code></li><li>每一条工作经历写完后或者引用论文后，要么全部加<code>.</code>要么全部不加<code>.</code>。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VTM中8比特与10比特转换</title>
      <link href="/2019/03/11/VTM%E4%B8%AD8%E6%AF%94%E7%89%B9%E4%B8%8E10%E6%AF%94%E7%89%B9%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/03/11/VTM%E4%B8%AD8%E6%AF%94%E7%89%B9%E4%B8%8E10%E6%AF%94%E7%89%B9%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>VVC中的输入视频可以是8比特SDR视频或者10比特HDR视频（通过<code>InputBitDepth</code>修改），编码器内部结构也可以设置为10比特或者8比特（通过<code>InternalBitDepth</code>修改）。</p><p>如果输入时8比特视频，编码器为10比特，则需要将8比特值x左移两位，变为4x，即<code>x&lt;&lt;2</code><br>如果输入为10比特视频，编码器为8比特，则需要将10比特值x右移两位，同时考虑四舍五入，变为 (x+2)/4，即<code>(x+2)&gt;&gt;2</code></p><p>相关提案参考<code>JVET-G1010-V2</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> VVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTM </tag>
            
            <tag> video coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控视频的特点分析</title>
      <link href="/2019/03/05/%E7%9B%91%E6%8E%A7%E8%A7%86%E9%A2%91%E7%9A%84%E7%89%B9%E7%82%B9%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/05/%E7%9B%91%E6%8E%A7%E8%A7%86%E9%A2%91%E7%9A%84%E7%89%B9%E7%82%B9%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>码率控制总结---步骤，流程</title>
      <link href="/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E6%AD%A5%E9%AA%A4/"/>
      <url>/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>讲述码率控制的具体步骤。<br>前面的两篇文章：<br><a href="https://kaixinzuochuxi.github.io/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93---%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%8F%8A%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/" target="_blank" rel="noopener">码率控制总结—简介，作用，目标及衡量标准</a><br><a href="https://kaixinzuochuxi.github.io/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">码率控制总结—相关对象</a></p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>码率控制的两个步骤：</p><ul><li>对给定的编码单位分配特定的bit</li><li>通过模型和给定的bit，计算出编码参数进行编码</li></ul><p>编码单位，指的是视频中的组织结构，和<a href="https://kaixinzuochuxi.github.io/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">码率控制总结—相关对象</a>中的一样，一般分为</p><ul><li>GOP</li><li>frame</li><li>ctu<h2 id="GOP级码率分配"><a href="#GOP级码率分配" class="headerlink" title="GOP级码率分配"></a>GOP级码率分配</h2>任务：在同一个序列的众多GOP中进行码率分配，确定当前GOP的bit数。</li></ul><h3 id="几个值得注意的问题"><a href="#几个值得注意的问题" class="headerlink" title="几个值得注意的问题"></a>几个值得注意的问题</h3><h4 id="序列中GOP的划分"><a href="#序列中GOP的划分" class="headerlink" title="序列中GOP的划分"></a>序列中GOP的划分</h4><p>目前来说HEVC里面都是固定GOP大小，264中有部分文章提到了adaptive GOP size但是理论性较浅。此问题值得深入探讨。</p><h4 id="如何在众多GOP中进行码率分配"><a href="#如何在众多GOP中进行码率分配" class="headerlink" title="如何在众多GOP中进行码率分配"></a>如何在众多GOP中进行码率分配</h4><p>这个问题探讨的是GOP级别码率分配的依据。定性的角度来看，依据可以有如下几个：</p><ol><li>编码前的GOP的视频内容特性<ul><li>GOP中帧的相似性</li><li>不同GOP的复杂度关系</li></ul></li><li>编码过程中的budget的修正<ul><li>损有余而补不足，在一定的窗口范围内平衡已编码GOP的超出/不足比特数</li></ul></li></ol><h3 id="GOP分配的具体步骤"><a href="#GOP分配的具体步骤" class="headerlink" title="GOP分配的具体步骤"></a>GOP分配的具体步骤</h3><p>目前来说，GOP级的分配都是按照如下步骤进行：</p><ul><li>根据 码率$bitrate$ 和 总帧数$N_{total}$ 计算 平均每帧的比特$R_{avg,f}$</li><li>根据 GOP中的帧数$N_{GOP}$ 和 平均每帧的比特$R_{avg,f}$ 计算 GOP的比特数$R_{GOP}$</li><li>根据 已编码部分实际消耗的比特 修正 GOP的比特数$R_{GOP}$</li><li>设定 最小的GOP比特数 ，不允许$R_{GOP}$低于这个值</li></ul><h2 id="帧级码率分配"><a href="#帧级码率分配" class="headerlink" title="帧级码率分配"></a>帧级码率分配</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> 码率控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码率控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>码率控制总结---相关对象</title>
      <link href="/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93-%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>承接<a href="https://kaixinzuochuxi.github.io/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93---%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%8F%8A%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/" target="_blank" rel="noopener">码率控制总结—简介，作用，目标及衡量标准</a>，继续总结码率控制涉及到的变量，对象</p><a id="more"></a><h1 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h1><p>此处将所有涉及到的变量，数据分为3类</p><ul><li>视频对象<ul><li>结构上<ul><li>GOP</li><li>帧</li><li>slice/tile</li><li>ctu</li></ul></li><li>源信息，主要是视频固有的信息<ul><li>分辨率，宽/高</li><li>内容信息</li><li>位置信息：总帧数/POC/raster scan</li></ul></li></ul></li><li>编码参数，进行编码时的具体参数。<ul><li>编码结构/帧的类型/TID</li><li>编码的决策参数：QP/lambda</li><li>具体的编码模式</li></ul></li><li>编码结果，编码结束后的RD信息等。<ul><li>失真D<ul><li>ssim，mse，psnr…</li><li>Y, U, V, YUV</li></ul></li><li>资源R<ul><li>bit，bpp， header bit…</li><li>actual，target</li></ul></li><li>RD关系<ul><li>关系</li><li>参数</li></ul></li></ul></li></ul><h2 id="视频的组织结构"><a href="#视频的组织结构" class="headerlink" title="视频的组织结构"></a>视频的组织结构</h2><p>序列<br>GOP<br>帧<br>条/片<br>CTU</p><h2 id="组织结构中的变量"><a href="#组织结构中的变量" class="headerlink" title="组织结构中的变量"></a>组织结构中的变量</h2><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h4 id="源信息"><a href="#源信息" class="headerlink" title="源信息"></a>源信息</h4><ul><li>序列中帧的宽度</li><li>序列中帧的高度</li><li>序列总帧数</li><li>视频内容<h4 id="编码参数"><a href="#编码参数" class="headerlink" title="编码参数"></a>编码参数</h4></li><li>序列的QP/码率</li><li>编码结构：RA/AI/LD</li><li>GOP的大小<h4 id="编码结果"><a href="#编码结果" class="headerlink" title="编码结果"></a>编码结果</h4></li><li>序列的失真</li><li>序列的码率<ul><li>给定码率</li><li>实际码率</li></ul></li><li>编码的时间</li></ul><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><h4 id="源信息-1"><a href="#源信息-1" class="headerlink" title="源信息"></a>源信息</h4><ul><li>序列中帧的宽度</li><li>序列中帧的高度</li><li>视频内容<h4 id="编码参数-1"><a href="#编码参数-1" class="headerlink" title="编码参数"></a>编码参数</h4></li><li>序列的QP/码率</li><li>编码结构：RA/AI/LD</li><li>GOP的大小<h4 id="编码结果-1"><a href="#编码结果-1" class="headerlink" title="编码结果"></a>编码结果</h4></li><li>GOP的失真</li><li>GOP的码率<ul><li>给定码率</li><li>实际码率</li></ul></li><li>编码的时间</li></ul><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><h4 id="源信息-2"><a href="#源信息-2" class="headerlink" title="源信息"></a>源信息</h4><ul><li>帧的宽度</li><li>帧的高度</li><li>图片内容</li></ul><h4 id="编码参数-2"><a href="#编码参数-2" class="headerlink" title="编码参数"></a>编码参数</h4><ul><li>当前帧的QP/lambda</li><li>帧的类型</li><li>ctu的大小</li><li>图片中ctu个数<h4 id="编码结果-2"><a href="#编码结果-2" class="headerlink" title="编码结果"></a>编码结果</h4></li><li>当前帧的失真</li><li>当前帧的bit/bpp<ul><li>给定</li><li>实际</li></ul></li><li>当前帧的RD模型</li></ul><h3 id="条-片"><a href="#条-片" class="headerlink" title="条/片"></a>条/片</h3><p>暂不考虑</p><h3 id="CTU"><a href="#CTU" class="headerlink" title="CTU"></a>CTU</h3><h4 id="源信息-3"><a href="#源信息-3" class="headerlink" title="源信息"></a>源信息</h4><ul><li>ctu的内容<h4 id="编码参数-3"><a href="#编码参数-3" class="headerlink" title="编码参数"></a>编码参数</h4></li><li><p>ctu的大小</p><h4 id="编码结果-3"><a href="#编码结果-3" class="headerlink" title="编码结果"></a>编码结果</h4></li><li><p>当前ctu的失真</p></li><li>当前ctu的bit/bpp<ul><li>给定</li><li>实际</li></ul></li><li>当前RD模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> 码率控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码率控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R-lambda的码率控制</title>
      <link href="/2019/03/05/R-lambda%E7%9A%84%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/05/R-lambda%E7%9A%84%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>码率控制总结---简介，作用，目标及衡量标准</title>
      <link href="/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93---%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%8F%8A%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/"/>
      <url>/2019/03/05/%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93---%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%8F%8A%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍了码率控制的 作用，目标及衡量标准。</p><a id="more"></a><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>对未编码视频给定一个码率，使得编码之后的视频码率尽可能接近给定码率，同时质量尽可能高</p><h1 id="目标及衡量标准"><a href="#目标及衡量标准" class="headerlink" title="目标及衡量标准"></a>目标及衡量标准</h1><p>码率控制有多个目标及衡量标准，列举如下：</p><h2 id="码率准确性"><a href="#码率准确性" class="headerlink" title="码率准确性"></a>码率准确性</h2><p>主要比较输出码率与给定码率的差距</p><p>$accuracy=|\frac{BR_{target}-BR_{actual}}{BR_{target}}|$</p><h2 id="RD性能"><a href="#RD性能" class="headerlink" title="RD性能"></a>RD性能</h2><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>主要分为3类，PSNR, SSIM, MSE</p><p>每一类可以分为，Y,U,V,YUV四个分量。前三个是三个分量的失真，最后是按照给定的规律计算出来的综合失真</p><p>一般来说序列D是每帧D的平均</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>一般来说考虑最后的平均码率</p><h3 id="RD综合考虑"><a href="#RD综合考虑" class="headerlink" title="RD综合考虑"></a>RD综合考虑</h3><h4 id="BD-BR"><a href="#BD-BR" class="headerlink" title="BD-BR"></a>BD-BR</h4><p>相同PSNR下，码率的节省情况。<br>为负表示质量相同码率节省，当前算法较优；为正表示质量相同码率增加，当前算法较劣。</p><h4 id="BD-PSNR"><a href="#BD-PSNR" class="headerlink" title="BD-PSNR"></a>BD-PSNR</h4><p>相同码率下，PSNR的变化情况。<br>为正表示相同码率下，视频的质量好，算法较优；为负则视频质量差，算法较劣。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> 码率控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码率控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐形守护者</title>
      <link href="/2019/02/27/%E9%9A%90%E5%BD%A2%E5%AE%88%E6%8A%A4%E8%80%85/"/>
      <url>/2019/02/27/%E9%9A%90%E5%BD%A2%E5%AE%88%E6%8A%A4%E8%80%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VTM中打印码率控制中间变量</title>
      <link href="/2019/02/26/VTM%E4%B8%AD%E6%89%93%E5%8D%B0%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F/"/>
      <url>/2019/02/26/VTM%E4%B8%AD%E6%89%93%E5%8D%B0%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要描述了在VTM中打印码率控制中间变量的方法，这些中间变量可以用来辅助分析RD模型<br><a id="more"></a></p><h2 id="几个值得注意的地方"><a href="#几个值得注意的地方" class="headerlink" title="几个值得注意的地方"></a>几个值得注意的地方</h2><ul><li>frame bpp计算是整帧的bit减去估计的header bit之后再计算bpp</li><li>输出frame 的target bit需要在buffer regularization之后，同时不同帧类型也会有refinement，所以针对3种类型要分别添加(AI，非AI的I，B/P)<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2>预期输出的格式如下，首先是格式，然后解释每一项具体内容<h3 id="IRAP帧"><a href="#IRAP帧" class="headerlink" title="IRAP帧"></a>IRAP帧</h3>对于IRAP，格式如下。注意，这些输出在编码得到的txt中为一行，在这里为了显示的方便，人为地进行分行，只要记住实际为1行就可以了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RC |Pic_comp_bits: 14655        </span><br><span class="line">|frame_level: </span><br><span class="line">|[IRAP madpp:23.078666    bpp:1.129687    bpp_1:20.429248 pic_lambda:92.377179    pic_QP:21]      |</span><br><span class="line">ctu_level: </span><br><span class="line">|[IRAP madpp:27.015124 bpp:1.281189    bpp_1:21.085979 ctu_lambda:97.747760    ctu_QP:21       no-update]      |</span><br><span class="line">|[IRAP madpp:14.089777 bpp:0.867920    bpp_1:16.233959 ctu_lambda:63.615234    ctu_QP:20       no-update]      |</span><br><span class="line">|[IRAP madpp:33.306836 bpp:1.789673    bpp_1:18.610572 ctu_lambda:78.206851    ctu_QP:20       no-update]      |</span><br><span class="line">|[IRAP madpp:23.004567 bpp:1.619629    bpp_1:14.203603 ctu_lambda:50.138345    ctu_QP:19       no-update]      |</span><br><span class="line">|[IRAP madpp:28.990221 bpp:1.972796    bpp_1:14.694994 ctu_lambda:51.288322    ctu_QP:19       no-update]      |</span><br><span class="line">|[IRAP madpp:10.071074 bpp:0.986747    bpp_1:10.206343 ctu_lambda:50.138345    ctu_QP:19       no-update]      |</span><br><span class="line">|[IRAP madpp:27.242691 bpp:2.680664    bpp_1:10.162665 ctu_lambda:50.138345    ctu_QP:19       no-update]      |</span><br><span class="line">|[IRAP madpp:20.061599 bpp:7.831473    bpp_1:2.561664  ctu_lambda:50.138345    ctu_QP:19       no-update]      |</span><br><span class="line">POC    0 TId: 0 ( I-SLICE, QP 21 )     102184 bits [Y 41.8476 dB    U 44.8285 dB    V 44.9024 dB] [MS-SSIM Y 0.995731    U 0.995461    V 0.996197] [Y MSE 67.9896  U MSE 34.2256  V MSE 33.6483] [ET    31 ] [L0 ] [L1 ]       |[pic_update:1.129687   1.022596 134.362311      112.467106]     |</span><br><span class="line">|[frame-level-para 103.366762  1.771833]</span><br></pre></td></tr></table></figure></li></ul><h3 id="输出内容的解释"><a href="#输出内容的解释" class="headerlink" title="输出内容的解释"></a>输出内容的解释</h3><h4 id="字符解释"><a href="#字符解释" class="headerlink" title="字符解释"></a>字符解释</h4><p>竖线|：用作python读取时的分割，没有具体。经过分割，可以分别得到整张图片的数据，CTU的数据和原始RC输出的数据。<br>冒号:：用作连接变量名称与具体数值成为键值对。</p><h4 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h4><p>第一行，RC表示码率控制标志位，Pic_comp_bits表示当前帧的目标码率<br>第二行，指出接下来是帧级的数据<br>第三行，IRAP表示当前帧为IRAP帧，madpp表示每个像素平均的CostIntra的指数值（具体可以查看RC代码）, bpp表示当前平均每像素的比特，bpp_1表示madpp/bpp的值，后续lambda和QP较好理解。<br>第四行，表示接下来数据为每个CTU的数据。<br>第五行到第12行，表示每个ctu的对应数据。格式与帧级相同，值得注意的是，no-update表示当前没有参数更新。没有更新是由于RC代码的逻辑造成的，可以查看TODO:xxxxx。如果没有打开LCURateCtrl也会没有输出<br>第13行，原始的RC输出，自行添加了SSIM的值，具体方法可以查看<a href="https://kaixinzuochuxi.github.io/2019/02/18/VTM%E4%B8%AD%E6%B7%BB%E5%8A%A0SSIM%E8%BE%93%E5%87%BA/" target="_blank" rel="noopener">VTM中添加SSIM输出</a><br>第14行，表示当前帧更新的结果，四个数值分别代表：目标bpp，实际bpp，用未更新的帧级模型参数和目标bpp算出来的lambda，用未更新的帧级模型参数和实际bpp算出来的lambda<br>第15行，最后的帧级参数</p><h3 id="其他帧"><a href="#其他帧" class="headerlink" title="其他帧"></a>其他帧</h3><p>此处格式针对其他B/P帧。或者非IRAP类型的I帧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RC |Pic_comp_bits: 5477 |</span><br><span class="line">frame_level: </span><br><span class="line">|[inter bpp:0.054858      pic_lambda:599.993553    pic_QP:29]     |</span><br><span class="line">ctu_level: </span><br><span class="line">|[inter ctu_bpp:0.054871    ctu_lambda:952.430397    ctu_QP:31    ctu_update:0.054858       0.000000        2708.769793 inf]    |</span><br><span class="line">|[inter ctu_bpp:0.063477    ctu_lambda:952.430397    ctu_QP:30    ctu_update:0.054858  0.000000        2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:0.076355    ctu_lambda:952.430397    ctu_QP:31    ctu_update:0.054858  0.000000 2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:0.183838    ctu_lambda:755.944507    ctu_QP:30    ctu_update:0.054858  0.000000        2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:0.093959    ctu_lambda:952.430397    ctu_QP:31    ctu_update:0.054858 0.000000        2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:0.117188    ctu_lambda:952.430397    ctu_QP:31    ctu_update:0.054858  0.000000        2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:0.174107    ctu_lambda:755.944507    ctu_QP:30    ctu_update:0.054858  0.000000        2708.769793     inf]    |</span><br><span class="line">|[inter ctu_bpp:1.200056    ctu_lambda:599.993553    ctu_QP:30    ctu_update:0.054858  0.000000        2708.769793     inf]    |</span><br><span class="line">POC    1 TId: 0 ( B-SLICE, QP 29 )       1968 bits [Y 37.4837 dB    U 43.8983 dB    V 42.7874 dB] [MS-SSIM Y 0.992570    U 0.994312    V 0.995101] [Y MSE 185.7087  U MSE 42.4000  V MSE 54.7597] [ET     4 ] [L0 0 ] [L1 0 ]</span><br><span class="line">  |[pic_update:0.054858   0.019391        2708.769793     11224.329493]|</span><br><span class="line">|[frame-level-para 41.068369   -1.015352]</span><br></pre></td></tr></table></figure></p><h4 id="变量解释-1"><a href="#变量解释-1" class="headerlink" title="变量解释"></a>变量解释</h4><ul><li>此处用inter表示非IRAP帧，某些情况下不够严谨，日后遇到例外进行修改</li><li>inter是对每个CTU会有参数更新，四个变量的意义与帧级相同：目标bpp，实际bpp，用未更新的帧级模型参数和目标bpp算出来的lambda，用未更新的帧级模型参数和实际bpp算出来的lambda</li><li>其余部分与IRAP时相同</li></ul><h1 id="中间变量的种类及加入位置"><a href="#中间变量的种类及加入位置" class="headerlink" title="中间变量的种类及加入位置"></a>中间变量的种类及加入位置</h1><p>将按照下面四个部分来具体展开本节</p><ul><li>文件</li><li>位置</li><li><p>具体语句</p><h2 id="宏开关-PrintTemporalResult"><a href="#宏开关-PrintTemporalResult" class="headerlink" title="宏开关 PrintTemporalResult"></a>宏开关 PrintTemporalResult</h2></li><li><p>作用<br>  控制所有的中间变量是否输出，是为输出，否为不输出</p></li><li>文件<br>  TypeDef.h </li><li>位置<br>  任意</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PrintTemporalResult                               1</span><br></pre></td></tr></table></figure><h2 id="帧级"><a href="#帧级" class="headerlink" title="帧级"></a>帧级</h2><h3 id="每帧的目标比特"><a href="#每帧的目标比特" class="headerlink" title="每帧的目标比特"></a>每帧的目标比特</h3><ul><li>文件<br>  EncGOP.cpp </li><li>位置<br>  compressGOP，分配完目标码率，refine之后，判断帧类型(给定初始QP,IRAP,AI, inter)的条件语句中</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">///// 非全I帧的条件中， m_pcRateCtrl-&gt;getRCPic()-&gt;setTargetBits(bits);之后，作为RA和AI的目标比特输出</span><br><span class="line">#if PrintTemporalResult  </span><br><span class="line">          printf(&quot;RC  |Pic_comp_bits: %d  |frame_level: &quot;, bits);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123; </span><br><span class="line">          printf(&quot;RC  |Pic_comp_bits: %d  |frame_level: &quot;, estimatedBits);</span><br><span class="line">#endif   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">///// 一般情况下，紧跟else</span><br><span class="line">#if PrintTemporalResult  </span><br><span class="line">        printf(&quot;RC  |Pic_comp_bits: %d  |frame_level: &quot;, estimatedBits);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="IRAP帧的参数"><a href="#IRAP帧的参数" class="headerlink" title="IRAP帧的参数"></a>IRAP帧的参数</h3><p>这些参数包括：</p><ul><li>MADPerPixel，16*16的块减去均值之后的MAD,除以像素的个数</li><li>bitsPerPixel，平均每个像素的比特</li><li>更正过的bpp(依据mad和bitsPerPixel计算得出，在R-$\lambda$中为<code>MADPerPixel / bitsPerPixel</code>)</li></ul><p>在此函数中，IRAP帧和他的CTU共享这个输出。<br>具体来说</p><ul><li>文件<br>  RateCtrl.cpp </li><li>位置<br>  calculateLambdaIntra,<code>return</code>之前</li><li>具体语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult </span><br><span class="line">  printf(&quot;|[IRAP madpp  %f  bpp  %f  bpp_1  %f  &quot;, MADPerPixel, bitsPerPixel, MADPerPixel / bitsPerPixel);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h3 id="inter帧的参数"><a href="#inter帧的参数" class="headerlink" title="inter帧的参数"></a>inter帧的参数</h3><ul><li>文件<br>  RateCtrl.cpp </li><li>位置<br>  estimatePicLambda,<code>estLambda = alpha * pow( bpp, beta );</code>之后</li><li>具体语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    estLambda = alpha * pow( bpp, beta );</span><br><span class="line">#if PrintTemporalResult </span><br><span class="line">    printf(&quot;|[inter bpp  %f  &quot;, bpp);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h3 id="每帧的-lambda-和QP"><a href="#每帧的-lambda-和QP" class="headerlink" title="每帧的$\lambda$和QP"></a>每帧的$\lambda$和QP</h3><ul><li>文件<br>  EncGOP.cpp </li><li>位置<br>  compressGOP，求解完$\lambda$和QP<br>  <code>lambda  = m_pcRateCtrl-&gt;getRCPic()-&gt;estimatePicLambda( listPreviousPicture, pcSlice-&gt;isIRAP());</code><br>  之后</li><li>具体语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">        printf(&quot;pic_lambda: %f  pic_QP: %d]  |ctu_level: &quot;, lambda, sliceQP);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="编码完成后目标比特，实际比特，目标-lambda-与实际-lambda"><a href="#编码完成后目标比特，实际比特，目标-lambda-与实际-lambda" class="headerlink" title="编码完成后目标比特，实际比特，目标$\lambda$与实际$\lambda$"></a>编码完成后目标比特，实际比特，目标$\lambda$与实际$\lambda$</h3><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  updateAlphaBetaIntra,判断帧的类型是否为IRAP之前</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">  double bpp_real = (double)m_picActualBits / (double)m_numberOfPixel;</span><br><span class="line">  double bpp_comp = (double)m_targetBits / (double)m_numberOfPixel;</span><br><span class="line"></span><br><span class="line">  printf(&quot;  |[pic_update:  %f  %f&quot;, bpp_comp, bpp_real);</span><br><span class="line">  printf(&quot;  %f  %f]  |&quot;, (alpha)*pow(bpp_comp, (beta)), (alpha)*pow(bpp_real, (beta)));</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="输出帧级参数"><a href="#输出帧级参数" class="headerlink" title="输出帧级参数"></a>输出帧级参数</h3><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  updateAlphaBetaIntra,更新完参数之后，<code>TRCParameter rcPara;</code>之前</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">  printf(&quot;|[frame-level-para  %f  %f]  \n&quot;, alpha, beta);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="CTU级"><a href="#CTU级" class="headerlink" title="CTU级"></a>CTU级</h2><h3 id="IRAP帧的CTU"><a href="#IRAP帧的CTU" class="headerlink" title="IRAP帧的CTU"></a>IRAP帧的CTU</h3><p>和IRAP帧的修改相同，不需要额外修改</p><h3 id="B-P帧的CTU"><a href="#B-P帧的CTU" class="headerlink" title="B/P帧的CTU"></a>B/P帧的CTU</h3><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  getLCUEstLambda,<code>return</code>之前</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">  printf(&quot;|[inter ctu_bpp  %f    ctu_lambda  %f  &quot;,bpp, estLambda);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="CTU的更新"><a href="#CTU的更新" class="headerlink" title="CTU的更新"></a>CTU的更新</h3><h4 id="IRAP"><a href="#IRAP" class="headerlink" title="IRAP"></a>IRAP</h4><p>无更新，但是需要对每个CTU加上结束符。同时在加上结束符之前判断是否打开CTU级码率控制，如果打开则按照前面的格式输出，如果未打开，则每个CTU的格式都是<code>|[no-ctu_rc]  |</code></p><ul><li>文件<br>  EncSlice.cpp</li><li>位置<br>  在<code>EncSlice::encodeCtus</code>中，<code>updateAfterCTU</code>之后</li><li>具体语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">      </span><br><span class="line">      if (!pCfg-&gt;getLCULevelRC())</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;|[no-ctu_rc]  |&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if (pcSlice-&gt;isIRAP())</span><br><span class="line">        &#123;</span><br><span class="line">          printf(&quot;no-update]  |&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h4 id="inter"><a href="#inter" class="headerlink" title="inter"></a>inter</h4><ul><li>文件<br>  RateCtrl.cpp </li><li><p>位置<br>  updateAfterCTU,更新参数之前</p></li><li><p>具体语句</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintTemporalResult  </span><br><span class="line">  double bpp_real = (double)m_LCUs[LCUIdx].m_actualBits / (double)m_LCUs[LCUIdx].m_numberOfPixel;</span><br><span class="line">  double bpp_comp = (double)m_LCUs[LCUIdx].m_targetBits / (double)m_LCUs[LCUIdx].m_numberOfPixel;</span><br><span class="line"></span><br><span class="line">  printf(&quot;ctu_update  %f  %f&quot;, bpp_comp, bpp_real);</span><br><span class="line">  printf(&quot;  %f  %f]  |&quot;, (alpha)*pow(bpp_comp, (beta)), (alpha)*pow(bpp_real, (beta)));</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="未打开CTU级码率控制时的修改"><a href="#未打开CTU级码率控制时的修改" class="headerlink" title="未打开CTU级码率控制时的修改"></a>未打开CTU级码率控制时的修改</h3><p>见CTU更新的IRAP部分</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> VVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTM </tag>
            
            <tag> video coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频编码python包框架</title>
      <link href="/2019/02/25/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81python%E5%8C%85%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/02/25/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81python%E5%8C%85%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要构思视频编码python包框架，主要功能及API。</p><p>对于类的描述：</p><ul><li>功能</li><li>成员</li><li>方法<a id="more"></a><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="读取输出的txt结果"><a href="#读取输出的txt结果" class="headerlink" title="读取输出的txt结果"></a>读取输出的txt结果</h2></li></ul><h3 id="几种基本的类"><a href="#几种基本的类" class="headerlink" title="几种基本的类"></a>几种基本的类</h3><h4 id="视频源信息"><a href="#视频源信息" class="headerlink" title="视频源信息"></a>视频源信息</h4><p><code>source()</code></p><ul><li>功能：<ul><li>储存视频源相关信息</li></ul></li><li>成员：<ul><li>帧的宽度<code>self.width</code></li><li>帧的高度<code>self.width</code></li></ul></li><li>方法：<ul><li>无<h5 id="视频源信息-序列"><a href="#视频源信息-序列" class="headerlink" title="视频源信息-序列"></a>视频源信息-序列</h5><code>source_info_seq</code></li></ul></li><li>功能<ul><li>储存序列的基本信息</li></ul></li><li>成员<ul><li>序列名称<code>self.name</code></li><li>序列中帧的宽度<code>self.width</code></li><li>序列中帧的高度<code>self.height</code></li><li>序列的帧率<code>self.frame_rate</code></li><li>序列的总帧数<code>self.total_frame</code></li></ul></li><li>方法<ul><li>无<h5 id="视频源信息-帧"><a href="#视频源信息-帧" class="headerlink" title="视频源信息-帧"></a>视频源信息-帧</h5><code>source_info_pic</code></li></ul></li><li><p>功能</p><ul><li>储存视频的每帧基础信息</li></ul></li><li><p>成员</p><ul><li>帧的显示顺序POC<code>self.poc</code></li><li>帧的宽度<code>self.width</code></li><li>帧的高度<code>self.height</code></li><li>帧的SATD<code>self.satd</code></li></ul></li><li><p>方法</p><ul><li>无<h4 id="编码参数类"><a href="#编码参数类" class="headerlink" title="编码参数类"></a>编码参数类</h4><h5 id="序列编码参数类"><a href="#序列编码参数类" class="headerlink" title="序列编码参数类"></a>序列编码参数类</h5></li></ul></li><li><p>功能</p><ul><li>储存整个序列的通用编码参数</li></ul></li><li>成员<ul><li>编码结构<code>self.mode</code></li><li>编码QP</li><li>ctu的大小</li><li>每帧ctu的个数</li></ul></li><li>方法<ul><li>无<h5 id="帧编码参数类"><a href="#帧编码参数类" class="headerlink" title="帧编码参数类"></a>帧编码参数类</h5></li></ul></li><li>功能<ul><li>储存每帧的编码参数</li></ul></li><li>成员<ul><li>帧的类型</li><li>帧的tid</li><li>QP</li><li>lambda</li><li>ctu的大小</li><li>每帧ctu的个数</li></ul></li><li>方法<ul><li>无</li></ul></li></ul><h4 id="失真D"><a href="#失真D" class="headerlink" title="失真D"></a>失真D</h4><ul><li>功能<ul><li>作为一个模板，生成各种失真类</li></ul></li><li>成员<ul><li>Y分量失真</li><li>U分量失真</li><li>V分量失真</li><li>YUV总失真</li></ul></li><li>方法<ul><li>无<h5 id="psnr"><a href="#psnr" class="headerlink" title="psnr"></a>psnr</h5></li></ul></li><li>功能<ul><li>储存每帧或每个序列的psnr值</li></ul></li><li>成员<ul><li>Y分量psnr</li><li>U分量psnr</li><li>V分量psnr</li><li>YUV总psnr</li></ul></li><li>方法<h5 id="ssim"><a href="#ssim" class="headerlink" title="ssim"></a>ssim</h5></li><li>功能</li><li>成员<ul><li>Y分量ssim</li><li>U分量ssim</li><li>V分量ssim</li><li>YUV总ssim</li></ul></li><li>方法<h5 id="mse"><a href="#mse" class="headerlink" title="mse"></a>mse</h5></li><li>功能</li><li>成员<ul><li>Y分量mse</li><li>U分量mse</li><li>V分量mse</li><li>YUV总mse</li></ul></li><li>方法</li></ul><h4 id="资源R"><a href="#资源R" class="headerlink" title="资源R"></a>资源R</h4><ul><li>功能<ul><li>作为一个模板，生成多种资源类</li></ul></li><li>成员<ul><li>目标资源</li><li>实际分得的资源</li></ul></li><li>方法<ul><li>无<h5 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h5></li></ul></li><li>功能<ul><li>储存每个编码单位的bit信息</li></ul></li><li>成员<ul><li>目标bit</li><li>实际bit</li></ul></li><li>方法<ul><li>无<h5 id="bpp"><a href="#bpp" class="headerlink" title="bpp"></a>bpp</h5></li></ul></li><li>功能<ul><li>储存每个单位的bpp信息</li></ul></li><li>成员<ul><li>目标bpp</li><li>实际bpp</li></ul></li><li>方法<ul><li>无</li></ul></li></ul><h4 id="编码结果类"><a href="#编码结果类" class="headerlink" title="编码结果类"></a>编码结果类</h4><h5 id="序列的编码结果"><a href="#序列的编码结果" class="headerlink" title="序列的编码结果"></a>序列的编码结果</h5><ul><li>功能<ul><li>储存序列的编码结果</li></ul></li><li>成员<ul><li>实际的输出码率</li><li>序列的psnr</li><li>序列的ssim</li><li>编码时间</li></ul></li><li>方法</li></ul><h5 id="帧的编码结果"><a href="#帧的编码结果" class="headerlink" title="帧的编码结果"></a>帧的编码结果</h5><ul><li>功能<ul><li>储存每帧的编码结果</li></ul></li><li>成员<ul><li>当前帧的失真<ul><li>psnr</li><li>ssim</li><li>mse</li></ul></li><li>当前帧的编码时间</li><li>当前帧的资源<ul><li>bit</li><li>bpp</li></ul></li><li>当前帧的参考列表<ul><li>列表0</li><li>列表1</li></ul></li></ul></li><li>方法</li></ul><h3 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h3><ul><li>功能<ul><li>储存每个图片的相关信息</li></ul></li><li>成员<ul><li>基本视频源信息</li><li>编码参数信息</li><li>编码结果信息</li></ul></li><li>方法<ul><li>读取当前帧数据并存到类的对应成员里面</li><li>读取当前帧的数据并存到ctu成员中</li></ul></li></ul><h3 id="序列类"><a href="#序列类" class="headerlink" title="序列类"></a>序列类</h3><ul><li>功能<ul><li>储存整个序列的相关信息</li></ul></li><li>成员<ul><li>基本视频源信息</li><li>编码参数信息</li><li>编码结果信息</li><li>序列中每帧的信息</li></ul></li><li>方法<ul><li>读取整个txt文件</li><li>读取每帧信息</li><li>读取有padding的每帧信息</li><li>读取最后的总结信息</li><li>读取编码所需时间</li></ul></li></ul><h2 id="分析原始yuv图像"><a href="#分析原始yuv图像" class="headerlink" title="分析原始yuv图像"></a>分析原始yuv图像</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video coding </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown插入参考文献</title>
      <link href="/2019/02/22/markdown%E6%8F%92%E5%85%A5%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"/>
      <url>/2019/02/22/markdown%E6%8F%92%E5%85%A5%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文主要针对如何在博客的markdown写作中插入参考文献进行了分析和讨论<br><a id="more"></a><br>几个参考文章：<br><a href="https://chalkit.tk/20171202-convert-markdown-inline-link-to-reference-footnote/" target="_blank" rel="noopener">https://chalkit.tk/20171202-convert-markdown-inline-link-to-reference-footnote/</a><br><a href="https://liuyun16.github.io/tools/2018-2-24-atom-markdown-zotero/" target="_blank" rel="noopener">https://liuyun16.github.io/tools/2018-2-24-atom-markdown-zotero/</a></p><p>1[^footnote]</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>预期目标是：</p><ul><li>在markdown写作中运用一种插入文献的方法，使得生成的博客能够显示出参考文献<ul><li>写作基于markdown，部署使用hexo，最终生成的是html</li></ul></li><li>参考文献应像latex的参考文献一样，具有动态更新的特性，即<ul><li>参考文献在文章中的插入地方 应与 最后的参考文献列表 具有关键词的对应关系</li></ul></li></ul><h1 id="现有的几种方法"><a href="#现有的几种方法" class="headerlink" title="现有的几种方法"></a>现有的几种方法</h1><ol><li><p>链接插入,参见第一篇文章，只能插入链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label like this, on a line by itself:</span><br><span class="line"></span><br><span class="line">[id]: http://example.com/  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure></li><li><p>脚注插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[^footnote]: Here is the *text* of the **footnote**.</span><br></pre></td></tr></table></figure></li></ol><p>存在问题：网站上显示时，会显示源代码而不是对应的格式,可以参考第一篇文章的方法解决。</p><ol start="3"><li>pandoc+bib<br>具体用法参考第二篇文章，但是并不适用与当前环境，因为使用pandoc是直接将<code>md</code>转换为<code>docx</code>，而在博客条件下我们是需要提供<code>md</code>让hexo帮我们生成<code>html</code>，所以这里暂时不讨论</li></ol><h1 id="最终选择的方法"><a href="#最终选择的方法" class="headerlink" title="最终选择的方法"></a>最终选择的方法</h1><p>最终选择用脚注的方式插入</p><h1 id="改进设想"><a href="#改进设想" class="headerlink" title="改进设想"></a>改进设想</h1><p>建立bib文件存储参考文献的信息，在原文中直接<code>\cite{xxx}</code>，然后编写一个Python文件将其替换为相应的标号和格式。</p><p>[^footnote]: a foot note</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python调用matlab程序</title>
      <link href="/2019/02/21/python%E8%B0%83%E7%94%A8matlab%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/02/21/python%E8%B0%83%E7%94%A8matlab%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何通过python调用matlab的<code>.m</code>文件，以及在调用中遇到的一些问题。</p><a id="more"></a><p>参考网址：<br><a href="https://blog.csdn.net/sunny_xsc1994/article/details/79254196" target="_blank" rel="noopener">两步解决python调用Matlab的脚本和函数文件</a><br><a href="https://blog.csdn.net/zyw_anquan/article/details/7756499" target="_blank" rel="noopener">如何在CMD下运用管理员权限</a><br><a href="https://blog.csdn.net/windymsth/article/details/78911310" target="_blank" rel="noopener">在CMD命令行中切换到管理员权限模式</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装python的matlab-engine包"><a href="#安装python的matlab-engine包" class="headerlink" title="安装python的matlab engine包"></a>安装python的matlab engine包</h2><p>此处和<a href="https://ww2.mathworks.cn/help/matlab/matlab_external/install-the-matlab-engine-for-python.html?ue" target="_blank" rel="noopener">官网</a>完全一致</p><h3 id="获取matlab文件夹路径"><a href="#获取matlab文件夹路径" class="headerlink" title="获取matlab文件夹路径"></a>获取matlab文件夹路径</h3><p>打开matlab，在命令行输入matlabroot，然后用返回值替代下面命令中的matlabroot</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>对于windows用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;matlabroot\extern\engines\python&quot;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>mac或者linux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;matlabroot/extern/engines/python&quot;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><h2 id="调用-m文件"><a href="#调用-m文件" class="headerlink" title="调用.m文件"></a>调用<code>.m</code>文件</h2><p>假设当前目录下存在<code>xxx.m</code>文件</p><h3 id="打开matlab"><a href="#打开matlab" class="headerlink" title="打开matlab"></a>打开matlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matlab.engine</span><br><span class="line">eng = matlab.engine.start_matlab()</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eng.xxx(nargout=0)</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eng.xxx(para1,para2...)</span><br></pre></td></tr></table></figure></p><p>第一个是当做脚本执行，第二个是当做函数执行，括号里面为参数。按照需要执行文件的类型进行选择。</p><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>如果python文件与matlab文件在同一个目录下，不需要考虑目录问题。</p><p>如果python文件与matlab文件不在一个目录下，则需要用os模块修改目录。</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>导入包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import matlab.engine</span><br></pre></td></tr></table></figure></p><p>修改当前目录到<code>.m</code>文件目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(&apos;xxxxxxx&apos;)</span><br></pre></td></tr></table></figure></p><p>启动matlab.engine,执行文件，和先前相同。</p><p>总结起来，必须要在<code>.m</code>文件目录启动matlab.engine。如果一开始在正确目录启动，后续使用<code>os.chdir</code>修改到其他目录仍然可以执行。如果一开始不在正确目录启动，即使后面使用<code>os.chdir</code>修改到正确目录也不行。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="安装matlab-engine时python没有管理员权限"><a href="#安装matlab-engine时python没有管理员权限" class="headerlink" title="安装matlab.engine时python没有管理员权限"></a>安装matlab.engine时python没有管理员权限</h2><p>这个问题是由于管理员限制matlab文件夹的权限造成的。问题会不会出现取决于当前是否为管理员用户。如果是，则不存在这个问题，如果不是，需要给定管理员权限。</p><p>最简单的方法，开始菜单中搜索cmd，右键选择管理员运行，然后cd到目标目录下，再用python安装即可。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编程语言 </category>
          
          <category> python </category>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next的主题配置尝试</title>
      <link href="/2019/02/19/Next%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%B0%9D%E8%AF%95/"/>
      <url>/2019/02/19/Next%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文就主题选择，应用，部分参数配置与碰到的一些问题进行了简单的总结。后续遇到新的问题会继续补充。</p><a id="more"></a><p>主要参考博客为<a href="http://saili.science/2017/04/02/github-for-win/" target="_blank" rel="noopener">http://saili.science/2017/04/02/github-for-win/</a></p><h1 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h1><p>在<a href="https://kaixinzuochuxi.github.io/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">GITHUB+HEXO搭建博客</a>的第一个<a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">链接</a>中给出了一些主题网站，里面可选的有很多，经过一些考虑，最终还是选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>。</p><p>具体原因如下：</p><ol><li>产品免费且受众广</li><li>功能上支持中文，支持文章目录生成。</li></ol><h1 id="主题的应用"><a href="#主题的应用" class="headerlink" title="主题的应用"></a>主题的应用</h1><p>按照<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">主题网站</a>提示即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>注意以后版本更新可能会导致命令(–branch v5.1.2)有一些差异，具体以<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">主题网站</a>为主。</p><p>此种方式也可用于配置其他主题，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx themes/xxx</span><br></pre></td></tr></table></figure></p><p>在themes目录下新建主题目录<code>xxx</code>，将主题文件复制到新建目录<code>xxx</code>下，然后修改主目录下_config.yml文件中的<code>theme: xxx</code>，重新<code>hexo g</code>和<code>hexo d</code>即可。</p><h1 id="部分参数配置"><a href="#部分参数配置" class="headerlink" title="部分参数配置"></a>部分参数配置</h1><h2 id="文章的目录全显示"><a href="#文章的目录全显示" class="headerlink" title="文章的目录全显示"></a>文章的目录全显示</h2><p>next主题默认文章标题是逐渐显示的，此处如果需要将文章目录全部展开，可以在<code>next\source\css\_custom\custom.styl</code>中添加一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="运动部分"><a href="#运动部分" class="headerlink" title="运动部分"></a>运动部分</h2><h1 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h1><h2 id="语言错误"><a href="#语言错误" class="headerlink" title="语言错误"></a>语言错误</h2><p>如果一开始把站点配置文件的语言设置为简体中文(zh-Hans), 可以查找<code>theme/next/languages</code>下的文件有没有<code>zh-Hans.yml</code>。如果没有，需要将<code>zh-CN.yml</code>改名为<code>zh-Hans.yml</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VTM中添加SSIM输出</title>
      <link href="/2019/02/18/VTM%E4%B8%AD%E6%B7%BB%E5%8A%A0SSIM%E8%BE%93%E5%87%BA/"/>
      <url>/2019/02/18/VTM%E4%B8%AD%E6%B7%BB%E5%8A%A0SSIM%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要介绍了在VTM中计算每帧SSIM的方法和步骤<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>主要解决的几个问题：</p><ul><li>数据存在哪里？SSIM作为一种失真度量，可以存在PSNR,MSE相同的Analyze类中</li><li>存储之后会进行哪些操作？计算每帧的YUV SSIM，最后输出整体SSIM</li><li>在哪里调用？编码完一帧后，计算PSNR之后调用计算每帧SSIM；最后输出summary时输出整个序列的SSIM<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2></li></ul><h3 id="Typedef-h-中加入宏"><a href="#Typedef-h-中加入宏" class="headerlink" title="Typedef.h 中加入宏"></a>Typedef.h 中加入宏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PrintSSIM 1</span><br></pre></td></tr></table></figure><h3 id="Analyze-h-中成员和函数"><a href="#Analyze-h-中成员和函数" class="headerlink" title="Analyze.h 中成员和函数"></a>Analyze.h 中成员和函数</h3><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><h5 id="ssim数组"><a href="#ssim数组" class="headerlink" title="ssim数组"></a>ssim数组</h5><p>Analyze.h 中，在class Analyze的private成员中加入double的ssim数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double    m_MSSSIM[MAX_NUM_COMPONENT];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><h5 id="Analyze-addResult"><a href="#Analyze-addResult" class="headerlink" title="Analyze::addResult"></a>Analyze::addResult</h5><p>Analyze.h 中，在class Analyze的private成员中加入新的addResult函数,传递SSIM参数。此处用于累加每帧SSIM用来输出最后sequence level的SSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM </span><br><span class="line">  void  addResult(double psnr[MAX_NUM_COMPONENT], double bits, const double MSEyuvframe[MAX_NUM_COMPONENT], const double MSSSIM[MAX_NUM_COMPONENT], bool isEncodeLtRef)</span><br><span class="line">#else</span><br><span class="line">  void  addResult( double psnr[MAX_NUM_COMPONENT], double bits, const double MSEyuvframe[MAX_NUM_COMPONENT]</span><br><span class="line">    , bool isEncodeLtRef</span><br><span class="line">  )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="新增访问ssim函数：getMsssim"><a href="#新增访问ssim函数：getMsssim" class="headerlink" title="新增访问ssim函数：getMsssim"></a>新增访问ssim函数：getMsssim</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double   getMsssim(ComponentID compID) const &#123; return  m_MSSSIM[compID]; &#125;</span><br><span class="line">#endif</span><br><span class="line">  double  getPsnr(ComponentID compID) const &#123; return  m_dPSNRSum[compID];  &#125;</span><br><span class="line">  double  getBits()                   const &#123; return  m_dAddBits;   &#125;</span><br><span class="line">  void    setBits(double numBits)     &#123; m_dAddBits = numBits; &#125;</span><br><span class="line">  uint32_t    getNumPic()                 const &#123; return  m_uiNumPic;   &#125;</span><br></pre></td></tr></table></figure><h4 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h4><h5 id="Analyze-addResult-1"><a href="#Analyze-addResult-1" class="headerlink" title="Analyze::addResult"></a>Analyze::addResult</h5><p>Analyze.h 中，addResult，SSIM数据的累加更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    for(uint32_t i=0; i&lt;MAX_NUM_COMPONENT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      m_dPSNRSum[i] += psnr[i];</span><br><span class="line">      m_MSEyuvframe[i] += MSEyuvframe[i];</span><br><span class="line">#if PrintSSIM</span><br><span class="line">      m_MSSSIM[i] += MSSSIM[i];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="Analyze-clear"><a href="#Analyze-clear" class="headerlink" title="Analyze::clear"></a>Analyze::clear</h5><p>Analyze.h 中，clear，SSIM数据归零：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      m_dPSNRSum[i] = 0;</span><br><span class="line">      m_MSEyuvframe[i] = 0;</span><br><span class="line">#if PrintSSIM</span><br><span class="line">      m_MSSSIM[i] = 0;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="Analyze-printout"><a href="#Analyze-printout" class="headerlink" title="Analyze::printout"></a>Analyze::printout</h5><p>Analyze.h 中，printout函数，负责输出最后的summary<br>一共8个地方需要添加：</p><ul><li>Y-MS-SSIM标志位</li><li>具体SSIM的数值，</li><li>依据是否为printMSEBasedSNR</li><li>400和其他的yuv格式</li></ul><p>8个地方的位置可以通过<code>if (printSequenceMSE)</code>来查找，直接放在<code>if (printSequenceMSE)</code>之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">400：</span><br><span class="line">#if PrintSSIM          </span><br><span class="line">          msg(e_msg_level, &quot;    Y-MS-SSIM&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">          msg(e_msg_level, &quot;    %8.6lf&quot;, getMsssim(COMPONENT_Y) / (double)getNumPic());</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">其他</span><br><span class="line">#if PrintSSIM</span><br><span class="line">              //printf(&quot;   Y-MS-SSIM    &quot; &quot;U-MS-SSIM    &quot; &quot;V-MS-SSIM &quot;);</span><br><span class="line">            msg(e_msg_level, &quot;    Y-MS-SSIM     &quot;  &quot;U-MS-SSIM     &quot;  &quot;V-MS-SSIM     &quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">            /*</span><br><span class="line">            printf(&quot;    %8.6lf     &quot; &quot;%8.6lf     &quot; &quot;%8.6lf &quot;,</span><br><span class="line">              getMsssim(COMPONENT_Y) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cb) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cr) / (double)getNumPic());</span><br><span class="line">              */</span><br><span class="line">            msg(e_msg_level, &quot;    %8.6lf     &quot; &quot;%8.6lf     &quot; &quot;%8.6lf &quot;,</span><br><span class="line">              getMsssim(COMPONENT_Y) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cb) / (double)getNumPic(),</span><br><span class="line">              getMsssim(COMPONENT_Cr) / (double)getNumPic());</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="EncGOP中的成员和函数"><a href="#EncGOP中的成员和函数" class="headerlink" title="EncGOP中的成员和函数"></a>EncGOP中的成员和函数</h3><h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><p>没有需要添加的成员</p><h4 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h4><h5 id="新增EncGOP-xCalculateAddPSNR"><a href="#新增EncGOP-xCalculateAddPSNR" class="headerlink" title="新增EncGOP::xCalculateAddPSNR"></a>新增EncGOP::xCalculateAddPSNR</h5><p>EncGOP.h中新增xCalculateMSSSIM，用来计算图片的SSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double xCalculateMSSSIM(const CPelBuf pcPic, const uint32_t orgStride, const CPelBuf cPicD, const uint32_t recStride, const uint32_t width, const uint32_t height, const uint32_t bitDepth);</span><br><span class="line">#endif</span><br><span class="line">  uint64_t xFindDistortionPlane(const CPelBuf&amp; pic0, const CPelBuf&amp; pic1, const uint32_t rshift</span><br></pre></td></tr></table></figure></p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><h5 id="EncGOP-xCalculateAddPSNR"><a href="#EncGOP-xCalculateAddPSNR" class="headerlink" title="EncGOP::xCalculateAddPSNR"></a>EncGOP::xCalculateAddPSNR</h5><p>一共有2个地方</p><ul><li>调用函数计算ssim</li><li>重载analyze模块的addResult函数</li></ul><p>calculate PSNR之后和<code>#if EXTENSION_360_VIDEO</code>之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  double  MSSSIM[MAX_NUM_COMPONENT] = &#123; 0,0,0 &#125;;</span><br><span class="line">  for (int chan = 0; chan&lt;::getNumberValidComponents(formatD); chan++)</span><br><span class="line">  &#123;</span><br><span class="line">    const ComponentID compID = ComponentID(chan);</span><br><span class="line"></span><br><span class="line">    const CPelBuf&amp;    p = picC.get(compID);</span><br><span class="line">    const CPelBuf&amp;    o = org.get(compID);</span><br><span class="line">    const int   orgStride = o.stride;</span><br><span class="line"></span><br><span class="line">    const int   recStride = p.stride;</span><br><span class="line">    const uint32_t   width = p.width - (m_pcEncLib-&gt;getPad(0) &gt;&gt; ::getComponentScaleX(compID, format));</span><br><span class="line">    const uint32_t   height = p.height - (m_pcEncLib-&gt;getPad(1) &gt;&gt; (!!bPicIsField + ::getComponentScaleY(compID, format)));</span><br><span class="line">    const uint32_t    bitDepth = sps.getBitDepth(toChannelType(compID));</span><br><span class="line"></span><br><span class="line">    MSSSIM[compID] = xCalculateMSSSIM(o, orgStride, p, recStride, width, height, bitDepth);</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>调用addPSNR时,选择新函数传递ssim成员,<br>all,I,P,B一共4个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  m_gcAnalyzeAll.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">  m_gcAnalyzeAll.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">    , isEncodeLtRef</span><br><span class="line">  );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeI.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeI.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeP.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeP.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">      , isEncodeLtRef</span><br><span class="line">    );</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PrintSSIM</span><br><span class="line">    m_gcAnalyzeB.addResult(dPSNRWeighted, (double)uibits, MSEyuvframeWeighted, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">    m_gcAnalyzeWPSNR.addResult(dPSNRWeighted, (double)uibits, MSEyuvframeWeighted, isEncodeLtRef);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>输出每帧信息，if( printFrameMSE )之前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">    printf(&quot; [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]&quot;, MSSSIM[COMPONENT_Y], MSSSIM[COMPONENT_Cb], MSSSIM[COMPONENT_Cr]);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if( printFrameMSE )</span><br><span class="line">    &#123;</span><br><span class="line">      msg( NOTICE, &quot; [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]&quot;, MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="EncGOP-xCalculateMSSSIM"><a href="#EncGOP-xCalculateMSSSIM" class="headerlink" title="EncGOP::xCalculateMSSSIM"></a>EncGOP::xCalculateMSSSIM</h5><p>在EncGOP::xCalculateAddPSNR之后，定义xCalculateMSSSIM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">double EncGOP::xCalculateMSSSIM(const CPelBuf pOrg, const uint32_t orgStride, const CPelBuf pRec, const uint32_t recStride, const uint32_t width, const uint32_t height, const uint32_t bitDepth)</span><br><span class="line">&#123;</span><br><span class="line">  const int MAX_MSSSIM_SCALE = 5;</span><br><span class="line">  const int WEIGHTING_MID_TAP = 5;</span><br><span class="line">  const int WEIGHTING_SIZE = WEIGHTING_MID_TAP * 2 + 1;</span><br><span class="line"></span><br><span class="line">  uint32_t maxScale;</span><br><span class="line"></span><br><span class="line">  // For low resolution videos determine number of scales </span><br><span class="line">  if (width &lt; 22 || height &lt; 22)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 44 || height &lt; 44)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 88 || height &lt; 88)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (width &lt; 176 || height &lt; 176)</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    maxScale = 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(maxScale&gt;0 &amp;&amp; maxScale &lt;= MAX_MSSSIM_SCALE);</span><br><span class="line"></span><br><span class="line">  //Normalized Gaussian mask design, 11*11, s.d. 1.5</span><br><span class="line">  double weights[WEIGHTING_SIZE][WEIGHTING_SIZE];</span><br><span class="line">  &#123;</span><br><span class="line">    double coeffSum = 0.0;</span><br><span class="line">    for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        weights[y][x] = exp(-((y - WEIGHTING_MID_TAP)*(y - WEIGHTING_MID_TAP) + (x - WEIGHTING_MID_TAP)*(x - WEIGHTING_MID_TAP)) / (WEIGHTING_MID_TAP - 0.5));</span><br><span class="line">        coeffSum += weights[y][x];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        weights[y][x] /= coeffSum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //Resolution based weights</span><br><span class="line">  const double exponentWeights[MAX_MSSSIM_SCALE][MAX_MSSSIM_SCALE] = &#123; &#123; 1.0,    0,      0,      0,      0 &#125;,</span><br><span class="line">  &#123; 0.1356, 0.8644, 0,      0,      0 &#125;,</span><br><span class="line">  &#123; 0.0711, 0.4530, 0.4760, 0,      0 &#125;,</span><br><span class="line">  &#123; 0.0517, 0.3295, 0.3462, 0.2726, 0 &#125;,</span><br><span class="line">  &#123; 0.0448, 0.2856, 0.3001, 0.2363, 0.1333 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">  //Downsampling of data:</span><br><span class="line">  std::vector&lt;double&gt; original[MAX_MSSSIM_SCALE];</span><br><span class="line">  std::vector&lt;double&gt; recon[MAX_MSSSIM_SCALE];</span><br><span class="line"></span><br><span class="line">  for (uint32_t scale = 0; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    original[scale].resize(scaledHeight*scaledWidth, double(0));</span><br><span class="line">    recon[scale].resize(scaledHeight*scaledWidth, double(0));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Initial [0] arrays to be a copy of the source data (but stored in array &quot;Double&quot;, not Pel array).</span><br><span class="line">  for (int y = 0; y&lt;height; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int x = 0; x&lt;width; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      original[0][y*width + x] = pOrg.buf[y*orgStride + x];</span><br><span class="line">      recon[0][y*width + x] = pRec.buf[y*recStride + x];</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set up other arrays to be average value of each 2x2 sample.</span><br><span class="line">  for (uint32_t scale = 1; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    for (int y = 0; y&lt;scaledHeight; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int x = 0; x&lt;scaledWidth; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        original[scale][y*scaledWidth + x] = (original[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          original[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x + 1] +</span><br><span class="line">          original[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          original[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x + 1]) / 4.0;</span><br><span class="line">        recon[scale][y*scaledWidth + x] = (recon[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          recon[scale - 1][2 * y   *(2 * scaledWidth) + 2 * x + 1] +</span><br><span class="line">          recon[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x] +</span><br><span class="line">          recon[scale - 1][(2 * y + 1)*(2 * scaledWidth) + 2 * x + 1]) / 4.0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Calculate MS-SSIM:</span><br><span class="line">  const uint32_t   maxValue = (1 &lt;&lt; bitDepth) - 1;</span><br><span class="line">  const double c1 = (0.01*maxValue)*(0.01*maxValue);</span><br><span class="line">  const double c2 = (0.03*maxValue)*(0.03*maxValue);</span><br><span class="line"></span><br><span class="line">  double finalMSSSIM = 1.0;</span><br><span class="line"></span><br><span class="line">  for (uint32_t scale = 0; scale&lt;maxScale; scale++)</span><br><span class="line">  &#123;</span><br><span class="line">    const int scaledHeight = height &gt;&gt; scale;</span><br><span class="line">    const int scaledWidth = width &gt;&gt; scale;</span><br><span class="line">    const int blocksPerRow = scaledWidth - WEIGHTING_SIZE + 1;</span><br><span class="line">    const int blocksPerColumn = scaledHeight - WEIGHTING_SIZE + 1;</span><br><span class="line">    const int totalBlocks = blocksPerRow * blocksPerColumn;</span><br><span class="line"></span><br><span class="line">    double meanSSIM = 0.0;</span><br><span class="line"></span><br><span class="line">    for (int blockIndexY = 0; blockIndexY&lt;blocksPerColumn; blockIndexY++)</span><br><span class="line">    &#123;</span><br><span class="line">      for (int blockIndexX = 0; blockIndexX&lt;blocksPerRow; blockIndexX++)</span><br><span class="line">      &#123;</span><br><span class="line">        double muOrg = 0.0;</span><br><span class="line">        double muRec = 0.0;</span><br><span class="line">        double muOrigSqr = 0.0;</span><br><span class="line">        double muRecSqr = 0.0;</span><br><span class="line">        double muOrigMultRec = 0.0;</span><br><span class="line"></span><br><span class="line">        for (int y = 0; y&lt;WEIGHTING_SIZE; y++)</span><br><span class="line">        &#123;</span><br><span class="line">          for (int x = 0; x&lt;WEIGHTING_SIZE; x++)</span><br><span class="line">          &#123;</span><br><span class="line">            const double gaussianWeight = weights[y][x];</span><br><span class="line">            const int    sampleOffset = (blockIndexY + y)*scaledWidth + (blockIndexX + x);</span><br><span class="line">            const double orgPel = original[scale][sampleOffset];</span><br><span class="line">            const double recPel = recon[scale][sampleOffset];</span><br><span class="line"></span><br><span class="line">            muOrg += orgPel * gaussianWeight;</span><br><span class="line">            muRec += recPel * gaussianWeight;</span><br><span class="line">            muOrigSqr += orgPel * orgPel*gaussianWeight;</span><br><span class="line">            muRecSqr += recPel * recPel*gaussianWeight;</span><br><span class="line">            muOrigMultRec += orgPel * recPel*gaussianWeight;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const double sigmaSqrOrig = muOrigSqr - (muOrg*muOrg);</span><br><span class="line">        const double sigmaSqrRec = muRecSqr - (muRec*muRec);</span><br><span class="line">        const double sigmaOrigRec = muOrigMultRec - (muOrg*muRec);</span><br><span class="line"></span><br><span class="line">        double blockSSIMVal = ((2.0*sigmaOrigRec + c2) / (sigmaSqrOrig + sigmaSqrRec + c2));</span><br><span class="line">        if (scale == maxScale - 1)</span><br><span class="line">        &#123;</span><br><span class="line">          blockSSIMVal *= (2.0*muOrg*muRec + c1) / (muOrg*muOrg + muRec * muRec + c1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        meanSSIM += blockSSIMVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meanSSIM /= totalBlocks;</span><br><span class="line"></span><br><span class="line">    finalMSSSIM *= pow(meanSSIM, exponentWeights[maxScale - 1][scale]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return finalMSSSIM;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h5 id="EncGOP-xCalculateInterlacedAddPSNR"><a href="#EncGOP-xCalculateInterlacedAddPSNR" class="headerlink" title="EncGOP::xCalculateInterlacedAddPSNR"></a>EncGOP::xCalculateInterlacedAddPSNR</h5><p>xCalculateInterlacedAddPSNR中暂时不修改，因为现在不需要field coding。但需要增加两项内容避免报错：</p><p>计算ssim,在计算psnr之后和<code>uint32_t uibits = 0;</code>之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  //===== calculate MS-SSIM =====</span><br><span class="line">  double MSSSIM[MAX_NUM_COMPONENT] = &#123; 0,0,0 &#125;;</span><br><span class="line">  /*</span><br><span class="line">  </span><br><span class="line">    for (int chan = 0; chan&lt;numValidComponents; chan++)</span><br><span class="line">    &#123;</span><br><span class="line">      const ComponentID ch = ComponentID(chan);</span><br><span class="line">      assert(acPicRecFields[0]-&gt;getWidth(ch) == acPicRecFields[1]-&gt;getWidth(ch));</span><br><span class="line">      assert(acPicRecFields[0]-&gt;getHeight(ch) == acPicRecFields[1]-&gt;getHeight(ch));</span><br><span class="line"></span><br><span class="line">      double sumOverFieldsMSSSIM = 0.0;</span><br><span class="line">      const uint32_t width = acPicRecFields[0].get(ch).width - (m_pcEncLib-&gt;getPad(0) &gt;&gt; ::getComponentScaleX(ch, format));</span><br><span class="line">      const uint32_t height = acPicRecFields[0].get(ch).height - ((m_pcEncLib-&gt;getPad(1) &gt;&gt; 1) &gt;&gt; ::getComponentScaleY(ch, format));</span><br><span class="line"></span><br><span class="line">      for (uint32_t fieldNum = 0; fieldNum&lt;2; fieldNum++)</span><br><span class="line">      &#123;</span><br><span class="line">        Picture    pcPic = *apcPicOrgFields[fieldNum];</span><br><span class="line">        PelUnitBuf pcPicD = acPicRecFields[fieldNum];</span><br><span class="line">        const CPelBuf&amp;    p = pcPic.get(ch);</span><br><span class="line">        const CPelBuf&amp;    o = pcPicD.get(ch);</span><br><span class="line">        const Pel*  pOrg = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic.getPicYuvTrueOrg()-&gt;getAddr(ch) : pcPic-&gt;getPicYuvOrg()-&gt;getAddr(ch);</span><br><span class="line">        const uint32_t   orgStride = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic-&gt;getPicYuvTrueOrg()-&gt;getStride(ch) : pcPic-&gt;getPicYuvOrg()-&gt;getStride(ch);</span><br><span class="line">        Pel*        pRec = pcPicD-&gt;getAddr(ch);</span><br><span class="line">        const uint32_t   recStride = pcPicD-&gt;getStride(ch);</span><br><span class="line">        const uint32_t  bitDepth = sps.getBitDepth(toChannelType(ch));</span><br><span class="line"></span><br><span class="line">        sumOverFieldsMSSSIM += xCalculateMSSSIM(pOrg, orgStride, pRec, recStride, width, height, bitDepth);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MSSSIM[ch] = sumOverFieldsMSSSIM / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>addResult，和先前非field coding编码一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if PrintSSIM</span><br><span class="line">  m_gcAnalyzeAll_in.addResult(dPSNR, (double)uibits, MSEyuvframe, MSSSIM, isEncodeLtRef);</span><br><span class="line">#else</span><br><span class="line">  m_gcAnalyzeAll_in.addResult(dPSNR, (double)uibits, MSEyuvframe</span><br><span class="line">    , isEncodeLtRef</span><br><span class="line">  );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 视频编码 </category>
          
          <category> VVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下C++编译</title>
      <link href="/2018/04/25/linux%E4%B8%8BC-%E7%BC%96%E8%AF%91/"/>
      <url>/2018/04/25/linux%E4%B8%8BC-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="linux下C-编译"><a href="#linux下C-编译" class="headerlink" title="linux下C++编译"></a>linux下C++编译</h1><a id="more"></a><p>本文来自<a href="http://wiki.ubuntu.org.cn/Compiling_Cpp" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/Compiling_Cpp</a></p><p>C++编译有不同指令，所有指令都需要源码作为输入，根据输出结果不同可以分为以下几类：</p><ul><li>生成可执行文件<br>单个文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g++ helloworld.cpp      # 生成a.out的可执行文件</span><br><span class="line">g++ helloworld.cpp -o helloworld    # 自定义可执行文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># g++是gcc的一个特殊版本，链接是使用C++标准库不使用C标准库，可以指定编译库的名称</span><br><span class="line">gcc helloworld.cpp -lstdc++ -o helloworld</span><br><span class="line"># 某些系统GCC安装也会有c++,可以替代g++</span><br><span class="line">c++ helloworld.cpp -o helloworld</span><br><span class="line"># 执行</span><br><span class="line">./xxx.out</span><br><span class="line">./xxx</span><br></pre></td></tr></table></figure></li></ul><p>多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ xxx.cpp xxx.cpp -o xxxx</span><br></pre></td></tr></table></figure></p><p>参数不需要<code>.h</code>文件，只需要<code>.cpp</code></p><ul><li>生成对象文件<br>仅编译，不链接城可执行文件，文件名默认与源文件名相同</li><li>编译预处理</li><li>生成汇编代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GITHUB+HEXO搭建博客</title>
      <link href="/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/11/GITHUB+HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍用github与hexo搭建个人博客。<br><a id="more"></a><br>网上此类文章比较多，在此列举几条，可以按照下面链接的内容一步一步操作。</p><ul><li>基本框架(安装程序，搭建博客，发表文章，配置信息，更改主题)<br><a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="noopener">https://github.com/limedroid/HexoLearning</a></li><li>域名等其他内容添加<br><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></li><li>常见报错<br><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%A1%B5%E9%9D%A2%E9%95%BF%E6%97%B6%E9%97%B4404" target="_blank" rel="noopener">https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%A1%B5%E9%9D%A2%E9%95%BF%E6%97%B6%E9%97%B4404</a></li><li><p>常见命令<br>  <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 新文章</span><br><span class="line">hexo new [layout] &lt;title&gt;   # layout缺省，使用 _config.yml中default_layout代替</span><br><span class="line"># generate</span><br><span class="line">hexo generate   #简写hexo g</span><br><span class="line">--deploy/-d 文件生成后立即部署网站</span><br><span class="line">--watch/-w  监视文件变动</span><br><span class="line"># 发布草稿</span><br><span class="line">hexo publish [layout] &lt;filename&gt;</span><br><span class="line"># server</span><br><span class="line">hexo server #默认端口4000</span><br><span class="line">-p/--port   指定端口</span><br><span class="line">-s/--static 只使用静态文件</span><br><span class="line">-l/--log    启动日记记录，使用覆盖记录格式</span><br><span class="line"></span><br><span class="line"># deploy</span><br><span class="line">hexo deploy # 简写为hexo d</span><br><span class="line">-g/--generate 部署之前预先生成静态文件</span><br><span class="line"></span><br><span class="line">未完待定</span><br></pre></td></tr></table></figure></li><li><p>写作格式：</p><ul><li>tags<ul><li>[tag1,tag2…]</li><li>YAML格式，类似markdown中的格式</li></ul></li></ul></li></ul><p>几个注意事项：</p><ul><li>本地部署<code>hexo s</code>的时候win10可能无法打开默认的<code>localhost:4000</code>，此时需要使用自定义端口<code>hexo s -p 3600</code></li><li>本地文件与<code>xxx.github.io</code>仓库中文件的关系：<ul><li>将本地目录中<code>public</code>文件夹下内容上传到仓库，本人在此文件夹下使用<code>git init</code>。</li><li>部署时可以直接在本地博客目录下使用<code>hexo g</code>,<code>hexo d</code>部署，如果当前已经部署导致报错，删除<code>.deploy_git</code>即可。</li><li>不要轻易使用<code>hexo clean</code>，此操作会重新生成<code>public</code>文件夹,从而导致<code>public</code>文件夹下<code>.git</code>被删除，需要重新与仓库建立关系。此处可使用<code>git push --force origin master</code>强行覆盖。</li></ul></li><li><code>xxx.github.io</code>网址上内容的更新需要一段时间，可以先本地测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/11/hello-world/"/>
      <url>/2018/04/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
